<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>電脳幾何空間</title>
    <style>
      :root {
        color-scheme: dark;
        --deck: 10deg;
        --neon: #0ff;
        --accent: #f0f;
        --deep: #090b1a;
        --grid: rgba(12, 46, 74, 0.7);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Inter", "游ゴシック体", sans-serif;
        background: radial-gradient(circle at top, rgba(12, 72, 114, 0.45), transparent 40%),
          linear-gradient(180deg, #02050b 0%, #0d0e1a 55%, #03050e 100%);
        color: #f5f5ff;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: linear-gradient(90deg, transparent 45%, rgba(255, 255, 255, 0.04) 50%),
          linear-gradient(180deg, transparent 45%, rgba(255, 255, 255, 0.03) 50%);
        background-size: 120px 120px;
        z-index: -2;
      }
      body::after {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(circle at 20% 20%, rgba(128, 255, 255, 0.08), transparent 40%),
          radial-gradient(circle at 80% 10%, rgba(244, 90, 255, 0.1), transparent 45%);
        z-index: -1;
        filter: blur(30px);
        opacity: 0.8;
      }
      .formula-layer {
        position: fixed;
        inset: 0;
        z-index: -3;
        pointer-events: none;
        background:
          radial-gradient(circle at 60% 35%, rgba(0, 255, 255, 0.04), transparent 45%),
          radial-gradient(circle at 30% 50%, rgba(255, 0, 255, 0.03), transparent 40%),
          conic-gradient(from 60deg at 50% 40%, rgba(255, 255, 255, 0.08), transparent 40%);
        animation: rotateBackground 65s linear infinite;
        overflow: hidden;
      }
      .formula-layer svg {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0.35;
        mix-blend-mode: screen;
        animation: driftFormulas 50s linear infinite;
      }
      .formula-layer svg text {
        fill: rgba(255, 255, 255, 0.55);
        letter-spacing: 0.2em;
        font-family: "Source Code Pro", "Courier New", monospace;
      }
      .formula-layer svg circle,
      .formula-layer svg path {
        filter: drop-shadow(0 0 12px rgba(0, 255, 255, 0.35));
      }
      main {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 2rem;
        padding: 2rem clamp(1rem, 4vw, 4rem) 4rem;
      }
      .panel {
        backdrop-filter: blur(24px);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 24px;
        padding: clamp(1.5rem, 3vw, 2.5rem);
        background: rgba(5, 9, 20, 0.75);
        box-shadow: 0 20px 60px rgba(2, 3, 7, 0.8);
      }
      h1,
      h2,
      h3 {
        font-weight: 600;
        line-height: 1.3;
      }
      .hero {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        position: relative;
        overflow: hidden;
      }
      .hero::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.12), transparent 50%);
        pointer-events: none;
      }
      .hero h1 {
        font-size: clamp(2.4rem, 4vw, 3.4rem);
      }
      .hero p {
        margin: 0;
        color: #cce3ff;
        max-width: 70ch;
      }
      .mode-selector {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      .mode-selector button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 999px;
        padding: 0.65rem 1.4rem;
        background: transparent;
        color: inherit;
        font-weight: 500;
        cursor: pointer;
        transition: border-color 0.2s ease, transform 0.2s ease;
      }
      .mode-selector button:hover {
        border-color: var(--neon);
        transform: translateY(-2px);
      }
      #fractal {
        display: grid;
        grid-template-columns: minmax(0, 420px) minmax(0, 1fr);
        gap: clamp(1.5rem, 3vw, 2.75rem);
      }
      .toc-panel {
        display: grid;
        gap: 1.5rem;
      }
      .toc-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
        gap: 0.75rem;
      }
      .toc-card {
        position: relative;
        border-radius: 18px;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.08);
        cursor: pointer;
        overflow: hidden;
        transition: border-color 0.2s ease, transform 0.2s ease;
      }
      .toc-card:hover {
        border-color: rgba(0, 255, 255, 0.6);
        transform: translateY(-4px);
      }
      .toc-card span {
        display: block;
        font-size: 0.8rem;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: rgba(204, 232, 255, 0.6);
      }
      .toc-card strong {
        display: block;
        margin-top: 0.35rem;
        font-size: 1rem;
      }
      .toc-input {
        position: absolute;
        inset: 0;
        z-index: 1;
        opacity: 0;
        cursor: pointer;
      }
      .toc-dots {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 4px;
        margin-top: 0.75rem;
      }
      .toc-dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: rgba(0, 255, 255, 0.4);
        box-shadow: inset 0 0 4px rgba(255, 255, 255, 0.4);
        transition: transform 0.2s ease;
      }
      .toc-card:hover .toc-dot {
        transform: scale(1.2);
      }
      .fractal-info {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .fractal-grid {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .control-group {
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
        align-items: center;
        font-size: 0.95rem;
      }
      .control-group label {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        color: #9ab4ff;
      }
      .control-group input[type="range"] {
        width: 100%;
      }
      .control-row {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      canvas {
        width: 100%;
        height: clamp(480px, 55vw, 660px);
        border-radius: 18px;
        background: rgba(3, 6, 15, 0.85);
        box-shadow: inset 0 0 40px rgba(0, 255, 255, 0.08);
      }
      button.primary {
        align-self: flex-start;
        padding: 0.85rem 1.6rem;
        border-radius: 999px;
        border: none;
        background: linear-gradient(120deg, rgba(0, 255, 255, 0.25), rgba(255, 255, 255, 0.1));
        color: #f3ffff;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      }
      #constants {
        position: relative;
        overflow: hidden;
      }
      #constants::after {
        content: "";
        position: absolute;
        inset: 10% 0;
        background: repeating-linear-gradient(90deg, transparent 0 20px, rgba(255, 255, 255, 0.04) 21px 40px);
        opacity: 0.4;
      }
      .constant-history {
        font-size: 0.95rem;
        color: #9dbaff;
        margin: 0;
        line-height: 1.5;
      }
      .constant-digits {
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 1rem;
        letter-spacing: 0.18em;
        color: #cce8ff;
        background: rgba(4, 10, 28, 0.9);
        border-radius: 14px;
        padding: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.08);
        min-height: 210px;
        max-height: 240px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-break: break-all;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.45);
      }
      .constants-display {
        position: relative;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
      }
      .constant-card {
        border-radius: 18px;
        padding: 1.2rem;
        background: rgba(2, 11, 32, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 10px 30px rgba(2, 4, 10, 0.8);
        min-height: 200px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      .approximation-panel {
        margin-top: 2rem;
        border-radius: 20px;
        padding: clamp(1.25rem, 2vw, 1.75rem);
        background: radial-gradient(circle at top, rgba(13, 55, 126, 0.25), transparent 60%),
          rgba(4, 10, 28, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 25px 55px rgba(1, 4, 12, 0.85);
      }
      .approximation-heading h3 {
        margin: 0;
        font-size: 1.4rem;
      }
      .approximation-heading p {
        margin: 0.4rem 0 0;
        color: #9dbaff;
        max-width: 60ch;
      }
      .approximation-grid {
        margin-top: 1.25rem;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
      }
      .approx-card {
        border-radius: 16px;
        padding: 1rem 1.1rem;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.05);
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
        position: relative;
        overflow: hidden;
      }
      .approx-card::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.01), transparent 60%);
        pointer-events: none;
        z-index: 0;
      }
      .approx-card-header {
        display: flex;
        flex-direction: column;
        color: #cce7ff;
        z-index: 1;
      }
      .approx-card-header span {
        font-size: 0.75rem;
        letter-spacing: 0.3em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.6);
      }
      .approx-card-header strong {
        font-size: 1.15rem;
        display: block;
        margin-top: 0.25rem;
      }
      .approx-formula {
        margin: 0;
        font-size: 0.85rem;
        color: #a1c4ff;
        font-family: "Source Code Pro", "Courier New", monospace;
        line-height: 1.4;
        z-index: 1;
      }
      .approx-value {
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 1.1rem;
        letter-spacing: 0.04em;
        color: #e3faff;
        z-index: 1;
      }
      .approx-progress {
        width: 100%;
        height: 4px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
        overflow: hidden;
        position: relative;
        z-index: 1;
      }
      .approx-progress-bar {
        height: 100%;
        display: block;
        background: linear-gradient(90deg, rgba(0, 255, 255, 0.8), rgba(255, 255, 255, 0.05));
        transition: width 0.2s ease;
      }
      .approx-meta {
        display: flex;
        justify-content: space-between;
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.7);
        z-index: 1;
      }
      .approx-iteration {
        font-size: 0.75rem;
        color: #9ab4ff;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        z-index: 1;
      }
      .approx-caption {
        margin: 0;
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.65);
        min-height: 2rem;
        z-index: 1;
      }
      .constant-card h3 {
        margin: 0;
        font-size: 1.2rem;
      }
      .constant-card p {
        margin: 0.8rem 0 0;
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 0.95rem;
        line-height: 1.5;
        white-space: pre-wrap;
        letter-spacing: 0.05em;
        color: #cce8ff;
      }
      #hanoi {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
      .hanoi-body {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
      }
      .tower-group {
        display: flex;
        flex: 1;
        justify-content: space-between;
        gap: 1rem;
      }
      .tower-column {
        flex: 1;
        min-width: 160px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        position: relative;
      }
      .tower-name {
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.2em;
        color: rgba(255, 255, 255, 0.7);
      }
      .tower {
        width: 100%;
        height: 210px;
        border-radius: 14px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(12, 18, 46, 0.8));
        border: 1px solid rgba(255, 255, 255, 0.08);
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        align-items: center;
        padding-bottom: 10px;
        box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.6);
        cursor: grab;
        transition: border-color 0.25s ease, box-shadow 0.25s ease, transform 0.25s ease;
      }
      .tower::after {
        content: "";
        position: absolute;
        width: 4px;
        height: 90%;
        background: rgba(255, 255, 255, 0.15);
        bottom: 10px;
        left: calc(50% - 2px);
        border-radius: 2px;
      }
      .tower:active {
        cursor: grabbing;
      }
      .tower-drag-source {
        border-color: var(--neon);
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.4), inset 0 0 35px rgba(255, 255, 255, 0.1);
      }
      .tower-drag-target {
        border-color: var(--accent);
        box-shadow: 0 0 30px rgba(244, 90, 255, 0.35), inset 0 0 28px rgba(255, 255, 255, 0.08);
      }
      .disk {
        height: 18px;
        border-radius: 12px 12px 4px 4px;
        margin-bottom: 6px;
        transition: transform 0.3s ease;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
        position: relative;
      }
      .disk::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .tower-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
      }
      .tower-controls label {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        color: #b7c5ff;
      }
      .tower-controls select,
      .tower-controls input[type="range"] {
        appearance: none;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 0.5rem 0.75rem;
        color: inherit;
      }
      .hanoi-actions {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }
      .hanoi-actions button {
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 999px;
        padding: 0.65rem 1.2rem;
        background: transparent;
        color: #f3ffff;
        font-weight: 500;
        cursor: pointer;
      }
      .hanoi-actions button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .message {
        min-height: 1.4rem;
        font-size: 0.9rem;
        color: #9ab4ff;
      }
      #circleGame {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .circle-game {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        align-items: flex-start;
        justify-content: space-between;
      }
      .circle-board {
        --board-size: 9;
        position: relative;
        min-width: 320px;
        width: min(520px, 100%);
        aspect-ratio: 1 / 1;
        border-radius: 18px;
        padding: 1rem;
        background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.08), transparent 60%),
          linear-gradient(90deg, rgba(255, 255, 255, 0.08) 1px, transparent 1px),
          linear-gradient(rgba(255, 255, 255, 0.08) 1px, transparent 1px);
        background-size: calc(100% / (var(--board-size) - 1)) calc(100% / (var(--board-size) - 1));
        display: grid;
        grid-template-columns: repeat(var(--board-size), 1fr);
        grid-template-rows: repeat(var(--board-size), 1fr);
        gap: 0;
        box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.7), 0 30px 50px rgba(5, 8, 25, 0.7);
      }
      #circleOverlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
        width: 100%;
        height: 100%;
      }
      .circle-cell {
        border: none;
        background: transparent;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        transition: transform 0.15s ease, opacity 0.2s ease;
      }
      .circle-cell::after {
        content: "";
        position: absolute;
        inset: 50%;
        transform: translate(-50%, -50%);
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.12);
        pointer-events: none;
      }
      .circle-cell .stone {
        width: 58%;
        height: 58%;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.4);
        box-shadow: 0 0 12px rgba(0, 255, 255, 0.35);
        transition: background 0.25s ease, box-shadow 0.25s ease;
      }
      .circle-cell[data-player="0"] .stone {
        opacity: 0;
        box-shadow: none;
      }
      .circle-cell[data-player="1"] .stone {
        background: radial-gradient(circle, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.6));
      }
      .circle-cell[data-player="2"] .stone {
        background: radial-gradient(circle, rgba(244, 90, 255, 0.85), rgba(244, 90, 255, 0.4));
      }
      .circle-cell.circle-cell--last {
        transform: scale(1.05);
      }
      .circle-game-info {
        flex: 1;
        min-width: 240px;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .circle-scoreboard {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.75rem;
      }
      .circle-scoreboard div {
        padding: 0.9rem;
        border-radius: 14px;
        background: rgba(10, 26, 50, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.4);
      }
      .circle-scoreboard strong {
        display: block;
        font-size: 0.85rem;
        letter-spacing: 0.2em;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 0.35rem;
      }
      .circle-scoreboard--wide {
        grid-column: 1 / -1;
      }
      .circle-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      .circle-controls label,
      .circle-controls button {
        font-size: 0.9rem;
      }
      .circle-controls select,
      .circle-controls button {
        appearance: none;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.05);
        color: inherit;
        padding: 0.5rem 0.9rem;
      }
      .circle-controls button {
        cursor: pointer;
      }
      .circle-message {
        min-height: 2rem;
        font-size: 0.95rem;
        color: #cbe8ff;
      }
      .circle-ai-info {
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.7);
        margin: 0;
      }
      #calcGrid {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
      .calc-grid-body {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
      }
      .calc-grid-board-wrapper {
        position: relative;
        width: min(720px, 100%);
        aspect-ratio: 12 / 10;
      }
      .calc-grid-board {
        display: grid;
        grid-template-columns: repeat(12, minmax(0, 1fr));
        gap: 6px;
        width: 100%;
        height: 100%;
        padding: 1rem;
        border-radius: 20px;
        background: radial-gradient(circle at 30% 20%, rgba(0, 255, 255, 0.08), transparent 60%),
          rgba(3, 8, 22, 0.9);
        box-shadow: inset 0 0 35px rgba(0, 0, 0, 0.7);
      }
      .calc-grid-overlay {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      .calc-grid-line {
        fill: none;
        stroke-width: 0.18;
        stroke-linecap: round;
        stroke-linejoin: round;
      }
      .calc-grid-line--path {
        stroke: rgba(111, 151, 255, 0.9);
      }
      .calc-grid-line--solution {
        stroke: rgba(255, 160, 160, 0.95);
        stroke-dasharray: 0.35 0.2;
      }
      .calc-grid-board button {
        position: relative;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
        color: inherit;
        font-weight: 600;
        font-size: 0.9rem;
        font-family: "Source Code Pro", "Courier New", monospace;
        cursor: pointer;
        transition: transform 0.1s ease, border-color 0.2s ease, background 0.2s ease;
      }
      .calc-grid-board button:active {
        transform: translateY(1px);
      }
      .calc-grid-board button:focus-visible {
        outline: 2px solid var(--neon);
        outline-offset: 2px;
      }
      .calc-cell-start {
        background: rgba(120, 200, 140, 0.45);
        border-color: rgba(120, 200, 140, 0.9);
      }
      .calc-cell-path {
        background: rgba(120, 140, 255, 0.35);
        border-color: rgba(120, 140, 255, 0.8);
      }
      .calc-cell-path[data-step]::before {
        content: attr(data-step);
        position: absolute;
        top: 6px;
        left: 8px;
        font-size: 0.65rem;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.9);
        padding: 2px 6px;
        border-radius: 999px;
        background: rgba(50, 70, 200, 0.7);
      }
      .calc-cell-best {
        background: rgba(255, 150, 150, 0.35);
        border-color: rgba(255, 150, 150, 0.8);
      }
      .calc-cell-best[data-solution-step]::after {
        content: attr(data-solution-step);
        position: absolute;
        bottom: 6px;
        right: 8px;
        font-size: 0.65rem;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.9);
        padding: 2px 6px;
        border-radius: 999px;
        background: rgba(200, 60, 60, 0.75);
      }
      .calc-grid-sidebar {
        flex: 1;
        min-width: 260px;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .calc-grid-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 0.75rem;
      }
      .calc-stat-card {
        padding: 0.9rem;
        border-radius: 14px;
        background: rgba(4, 12, 30, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.08);
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .calc-stat-card strong {
        font-size: 0.75rem;
        letter-spacing: 0.2em;
        color: rgba(255, 255, 255, 0.6);
        text-transform: uppercase;
      }
      .calc-stat-card span {
        font-size: 1.35rem;
        font-weight: 600;
        color: #f8fbff;
      }
      .calc-grid-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      .calc-grid-controls button {
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 999px;
        padding: 0.6rem 1.4rem;
        background: rgba(255, 255, 255, 0.04);
        color: inherit;
        cursor: pointer;
        font-weight: 500;
        transition: border-color 0.2s ease, transform 0.15s ease;
      }
      .calc-grid-controls button:hover:not(:disabled) {
        border-color: rgba(0, 255, 255, 0.6);
        transform: translateY(-2px);
      }
      .calc-grid-controls button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .calc-grid-message {
        min-height: 2.2rem;
        margin: 0;
        font-size: 0.95rem;
        color: #c7ddff;
      }
      .calc-grid-alert {
        padding: 0.75rem 1rem;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
        font-size: 0.9rem;
        color: #ffbcca;
      }
      .calc-grid-legend {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.4rem;
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.75);
      }
      .calc-legend-item {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
      }
      .calc-legend-box {
        width: 16px;
        height: 16px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.4);
      }
      .calc-legend-start {
        background: rgba(120, 200, 140, 0.6);
        border-color: rgba(120, 200, 140, 0.9);
      }
      .calc-legend-path {
        background: rgba(120, 140, 255, 0.5);
        border-color: rgba(120, 140, 255, 0.8);
      }
      .calc-legend-best {
        background: rgba(255, 150, 150, 0.5);
        border-color: rgba(255, 150, 150, 0.8);
      }
      .calc-grid-history {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .calc-history-section {
        padding: 0.9rem 1rem;
        border-radius: 16px;
        background: rgba(6, 14, 32, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }
      .calc-history-title {
        display: block;
        font-size: 0.8rem;
        letter-spacing: 0.25em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 0.4rem;
      }
      .calc-history-list {
        list-style: none;
        margin: 0;
        padding: 0;
        max-height: 180px;
        overflow-y: auto;
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 0.85rem;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }
      .calc-history-list li {
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
        padding: 0.35rem 0.4rem;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.03);
      }
      .calc-history-empty {
        color: rgba(255, 255, 255, 0.5);
        font-style: italic;
        justify-content: flex-start;
      }
      #aliquot {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
      .aliquot-body {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
      }
      .aliquot-animation {
        flex: 1;
        min-width: 280px;
        border-radius: 20px;
        padding: 1.25rem;
        background: radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.08), transparent 60%),
          rgba(6, 12, 32, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.08);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .aliquot-orbit {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        min-height: 120px;
      }
      .aliquot-node {
        position: relative;
        padding: 0.75rem 1rem;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(255, 255, 255, 0.04);
        min-width: 82px;
        text-align: center;
        font-weight: 600;
        font-size: 1rem;
        color: #f7fcff;
        transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
      }
      .aliquot-node::after {
        content: "→";
        position: absolute;
        right: -0.85rem;
        top: 50%;
        transform: translateY(-50%);
        color: rgba(255, 255, 255, 0.45);
      }
      .aliquot-node:last-child::after {
        display: none;
      }
      .aliquot-node--active {
        border-color: var(--neon);
        box-shadow: 0 0 18px rgba(0, 255, 255, 0.35);
        transform: translateY(-4px);
      }
      .aliquot-explanation {
        background: rgba(255, 255, 255, 0.02);
        border-radius: 16px;
        padding: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.06);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .aliquot-explanation p {
        margin: 0;
        font-size: 0.95rem;
        color: #cde7ff;
      }
      .aliquot-divisors {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
        margin: 0;
        padding: 0;
        list-style: none;
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 0.9rem;
      }
      .aliquot-divisors li {
        padding: 0.2rem 0.5rem;
        border-radius: 10px;
        background: rgba(0, 255, 255, 0.08);
      }
      .aliquot-controls {
        flex: 1;
        min-width: 280px;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .aliquot-form {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: flex-end;
      }
      .aliquot-form label {
        flex: 1;
        min-width: 200px;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        color: #bcd5ff;
      }
      .aliquot-form input {
        appearance: none;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.04);
        color: inherit;
        padding: 0.65rem 0.75rem;
        font-size: 1rem;
      }
      .aliquot-form button {
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.05);
        color: inherit;
        padding: 0.65rem 1.4rem;
        cursor: pointer;
        font-weight: 600;
        transition: border-color 0.2s ease, transform 0.2s ease;
      }
      .aliquot-form button:hover:not(:disabled) {
        border-color: rgba(0, 255, 255, 0.6);
        transform: translateY(-2px);
      }
      .aliquot-status {
        min-height: 2rem;
        font-size: 0.95rem;
        color: #d7ecff;
      }
      .aliquot-sequence {
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
      }
      .aliquot-sequence h3 {
        margin: 0;
        font-size: 1rem;
      }
      .aliquot-sequence-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 0.95rem;
      }
      .aliquot-sequence-list li {
        padding: 0.3rem 0.5rem;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.05);
      }
      .aliquot-sequence-list li[data-cycle="true"] {
        background: rgba(255, 0, 255, 0.12);
        border: 1px solid rgba(255, 0, 255, 0.35);
      }
      .aliquot-replay {
        align-self: flex-start;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 0.7rem 1.6rem;
        background: rgba(0, 255, 255, 0.08);
        color: inherit;
        cursor: pointer;
        font-weight: 600;
      }
      .aliquot-replay:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      @keyframes driftFormulas {
        0% {
          transform: translate(0%, 0%);
        }
        100% {
          transform: translate(-15%, -10%);
        }
      }
      @keyframes rotateBackground {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      @media (max-width: 900px) {
        #fractal {
          grid-template-columns: 1fr;
        }
      }
      @media (max-width: 600px) {
        .tower-group {
          flex-direction: column;
        }
      }
      #mathIntroOverlay {
        position: fixed;
        inset: 0;
        background: radial-gradient(circle at 30% 30%, rgba(10, 141, 255, 0.25), transparent 50%),
          radial-gradient(circle at 70% 20%, rgba(255, 82, 255, 0.18), transparent 55%),
          rgba(2, 5, 12, 0.95);
        overflow: hidden;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        padding: 1rem;
        gap: 1rem;
        transition: opacity 0.8s ease;
      }
      #mathIntroOverlay::before {
        content: "";
        position: absolute;
        inset: 8%;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 30px;
        pointer-events: none;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
      }
      #mathIntroOverlay.math-intro-hidden {
        opacity: 0;
        pointer-events: none;
      }
      #mathIntroCanvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }
      .math-intro-copy {
        position: relative;
        z-index: 10;
        text-align: center;
        max-width: 80ch;
      }
      .math-intro-copy h2 {
        margin: 0 0 0.25rem;
        font-size: clamp(1.5rem, 3vw, 2.4rem);
      }
      .math-intro-copy p {
        margin: 0;
        color: rgba(255, 255, 255, 0.85);
      }
      .math-intro-copy .math-intro-tagline {
        margin-top: 0.5rem;
        letter-spacing: 0.3em;
        font-size: 0.75rem;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.55);
      }
      .math-intro-copy small {
        display: inline-block;
        margin-top: 0.5rem;
        font-size: 0.75rem;
        letter-spacing: 0.3em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.6);
      }
    </style>
  </head>
  <body>
    <div id="mathIntroOverlay" aria-label="数学的オープニング">
      <canvas id="mathIntroCanvas"></canvas>
      <div class="math-intro-copy">
        <h2>Deep Dive into Numbers</h2>
        <p>立体的な軌道が渦巻き、螺旋の奥へと吸い込まれるように、数学の深淵へと誘う。自動で収束する演算のリズムとともに、次第に現れた真理の光がページを照らしだす。</p>
        <span class="math-intro-tagline">Descend · Accelerate · Illuminate</span>
        <small>Click anywhere to jump forward</small>
      </div>
    </div>
    <div class="formula-layer" aria-hidden="true">
      <svg viewBox="0 0 720 240" preserveAspectRatio="xMidYMid slice">
        <text x="20" y="50" font-size="32">∑_{n=1}^∞ 1/n^2 = π^2/6</text>
        <text x="20" y="100" font-size="32">e^{iπ} + 1 = 0</text>
        <text x="20" y="150" font-size="26">ζ(s) = ∑_{n=1}^∞ 1/n^s</text>
        <text x="20" y="200" font-size="26">f(z)=z^2+c ... フラクタル軌跡</text>
        <circle cx="540" cy="120" r="60" stroke-width="1.5" stroke="rgba(255,255,255,0.25)" fill="none" />
        <circle cx="600" cy="60" r="32" stroke-width="0.6" stroke="rgba(0,255,255,0.4)" fill="none" />
        <path d="M420 40 Q 470 20 520 60" stroke="rgba(255,255,255,0.4)" stroke-width="1" fill="none" />
      </svg>
    </div>
    <main>
      <section class="panel hero">
        <p class="eyebrow">知の探求</p>
        <h1>幾何学的な装飾と知的な遊び</h1>
        <p>
          こちらは線と光の言語で構成されたミステリアスなインターフェース。幾何学パターンの
         調整、定数の美しい浮遊、そして証明にも使われるハノイの塔からアリコット数列まで、一つの流れにまとめた。
        </p>
        <div class="mode-selector">
          <button class="mode-button" data-target="fractal">フラクタルモード</button>
          <button class="mode-button" data-target="constants">定数表示</button>
          <button class="mode-button" data-target="hanoi">ハノイの塔</button>
        </div>
      </section>

      <section class="panel toc-panel">
        <div>
          <h2>目次</h2>
          <p>各セクションへ格子状に配置したドットを選んで移動します。</p>
        </div>
        <div class="toc-grid">
          <label class="toc-card">
            <input class="toc-input" type="button" data-target="fractal" />
            <span>フラクタル</span>
            <strong>幾何学模様</strong>
            <div class="toc-dots">
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
            </div>
          </label>
          <label class="toc-card">
            <input class="toc-input" type="button" data-target="constants" />
            <span>定数群</span>
            <strong>π と e</strong>
            <div class="toc-dots">
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
            </div>
          </label>
          <label class="toc-card">
            <input class="toc-input" type="button" data-target="hanoi" />
            <span>論理遊び</span>
            <strong>ハノイの塔</strong>
            <div class="toc-dots">
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
            </div>
          </label>
          <label class="toc-card">
            <input class="toc-input" type="button" data-target="circleGame" />
            <span>円状ゲーム</span>
            <strong>円上の4点目を避ける</strong>
            <div class="toc-dots">
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
            </div>
          </label>
          <label class="toc-card">
            <input class="toc-input" type="button" data-target="calcGrid" />
            <span>計算マス</span>
            <strong>数値探索</strong>
            <div class="toc-dots">
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
            </div>
          </label>
          <label class="toc-card">
            <input class="toc-input" type="button" data-target="aliquot" />
            <span>数論遊戯</span>
            <strong>アリコット列</strong>
            <div class="toc-dots">
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
            </div>
          </label>
        </div>
      </section>

      <section id="fractal" class="panel">
        <div class="fractal-info">
          <div>
            <h2>フラクタルで幾何学模様を自在に描く</h2>
            <p>
              分岐の角度や再帰の深さ、縮尺を操作しながら、空間に枝を伸ばしていく。選んだ色が
              ネオンのように幽玄な枝を染め上げる。
            </p>
          </div>
          <div class="fractal-grid">
            <div class="control-row">
              <label>
                フラクタルタイプ
                <select id="fractalType">
                  <option value="tree">枝分かれの森</option>
                  <option value="triangle">シェルピンスキーの三角形</option>
                  <option value="spiral">渦巻く黄金スパイラル</option>
                </select>
              </label>
              <label>
                線の色
                <input type="color" id="branchColor" value="#00ffff" />
              </label>
            </div>
            <div class="control-row">
              <label>
                深さ <span id="depthValue">6</span>
                <input type="range" id="depthRange" min="3" max="8" value="6" />
              </label>
              <label>
                角度 <span id="angleValue">30°</span>
                <input type="range" id="angleRange" min="15" max="60" value="30" />
              </label>
            </div>
            <div class="control-row">
              <label>
                縮尺 <span id="scaleValue">70%</span>
                <input type="range" id="scaleRange" min="50" max="85" value="70" />
              </label>
              <label>
                枝の数 <span id="branchCountValue">3</span>
                <input type="range" id="branchFactorRange" min="2" max="5" value="3" />
              </label>
            </div>
          </div>
        </div>
        <canvas id="fractalCanvas" width="800" height="600"></canvas>
      </section>

      <section id="constants" class="panel">
        <h2>円周率とネイピア数の電脳詩</h2>
        <p>
          背景に浮かぶグリッドを透かして、π と e の数列がサイバーな光の帯となって流れてゆく。
          思考の奥にある普遍性を見つめる。
        </p>
        <div class="constants-display">
          <article class="constant-card">
            <h3>π (Pi)</h3>
            <p class="constant-history">
              計測の始まりは古代に遡り、バビロニアやエジプトでは円周と直径の比に関する簡易な分数が実務に使われた。
              アルキメデスは多角形の内接・外接の周を押し広げる方法でπの上下限を掴み、極限と無限の世界へと橋を架けた。
            </p>
            <p class="constant-history">
              中国の祖沖之（そちゅうし）が後にπを355/113として近似し、インドやアラビアの数学者たちは双曲線や三角関数の級数を通じて新しい収束式を発見した。
              近代ではライプニッツ級数、ヴァイエルシュトラスの乗法分解、ラムジー＝ナイキストの正規分布との結びつきなど、多様な視座からπを追跡している。
            </p>
            <p class="constant-history">
              計算機科学の進化とともに、Gauss–Legendre や Chudnovsky らの高速収束アルゴリズムが開発され、現在では何兆桁ものπが記録されている。
              空間の測定、信号処理、波の解析ではいまだにこの比率があらゆる周回の周期と調和を支えており、再帰的な収束がその美しさを示す。
            </p>
            <p class="constant-history">
              さらに、確率論での円周率はガウス積分やブラウン運動の分布にも現れ、量子場理論の中で真空の揺らぎがπと対話している。
              そのため「πの深さ」を語る度に、古代から量子の時代まで、思考の螺旋が広がっていく。
            </p>
            <pre class="constant-digits" id="piDigits" aria-label="円周率の桁"></pre>
          </article>
          <article class="constant-card">
            <h3>e (ネイピア数)</h3>
            <p class="constant-history">
              ジョン・ネイピアは座標の間の「成長はどこまで進むのか」を計るために自然対数を導入し、そこから達したのがeという自然な拡張だ。
              つまり、1を連続的に複利計算したときの極限としてeが現れ、複利の「次の刻」へと滑らかに移る最速の速さを表す。
            </p>
            <p class="constant-history">
              微分・積分の基本定理では、e^x の導関数と積分が自らに戻るという奇跡があって、解析学とともにこの数が「微分の単位」を定めた。
              オイラーの公式 e^{iθ} = cosθ + i sinθ の鋭い幾何学的直感は、円周（π）と成長（e）が複素平面で同じ呼吸をしている証拠である。
            </p>
            <p class="constant-history">
              収束の速さを示す例としては、1/n! の級数や、連分数による表現があり、階乗の逆数が急速に減衰するのでわずかな項で多くの桁を確定できる。
              その性質が計算機の内部では指数的な精度を保証し、金融、統計、シミュレーションの直感的エンジンとして不可欠。
            </p>
            <p class="constant-history">
              今日の機械学習でも指数関数は活性化や正規化に現れ、情報の重みを滑らかに整えてくれるその力は、まさに「成長のなめらかさ」を体現している。
              数値を並べるだけでなく、こうした構造を理解することがeの真の魅力なのである。
            </p>
            <pre class="constant-digits" id="eDigits" aria-label="ネイピア数の桁"></pre>
          </article>
        </div>
        <div class="approximation-panel">
          <div class="approximation-heading">
            <h3>高速な近似の瞬間</h3>
            <p>桁をひとつずつ並べるのではなく、アルゴリズム的に跳躍的に収束する演算の熱を可視化する。目には映らない計算機の鼓動をドットに映し、π と e を高速で演算する近似式の魅力を体感してみてほしい。</p>
          </div>
          <div class="approximation-grid">
            <article class="approx-card">
              <div class="approx-card-header">
                <span>π</span>
                <strong>Gauss–Legendre</strong>
              </div>
              <p class="approx-formula" id="piFormula"></p>
              <div class="approx-value" id="piApproxValue"></div>
              <div class="approx-progress">
                <span id="piApproxProgress" class="approx-progress-bar"></span>
              </div>
              <div class="approx-meta">
                <span>桁数 <strong id="piApproxDigits">0</strong></span>
                <span class="approx-speed">Quadratic convergence</span>
              </div>
              <div class="approx-iteration" id="piIteration">Iteration 01</div>
              <p class="approx-caption" id="piCaption"></p>
            </article>
            <article class="approx-card">
              <div class="approx-card-header">
                <span>e</span>
                <strong>Σ 1/n!</strong>
              </div>
              <p class="approx-formula" id="eFormula"></p>
              <div class="approx-value" id="eApproxValue"></div>
              <div class="approx-progress">
                <span id="eApproxProgress" class="approx-progress-bar"></span>
              </div>
              <div class="approx-meta">
                <span>桁数 <strong id="eApproxDigits">0</strong></span>
                <span class="approx-speed">Factorial decay</span>
              </div>
              <div class="approx-iteration" id="eIteration">Iteration 01</div>
              <p class="approx-caption" id="eCaption"></p>
            </article>
          </div>
        </div>
      </section>

      <section id="hanoi" class="panel">
        <h2>ハノイの塔で論理を遊ぶ</h2>
        <p>
          解くには注意深い論理が必要。ディスクの枚数を変えて適応し、塔を移し替える感覚を直感的に確かめてほしい。
        </p>
        <div class="hanoi-body">
          <div class="tower-group">
            <div class="tower-column">
              <span class="tower-name">塔 A</span>
              <div class="tower" data-index="0"></div>
            </div>
            <div class="tower-column">
              <span class="tower-name">塔 B</span>
              <div class="tower" data-index="1"></div>
            </div>
            <div class="tower-column">
              <span class="tower-name">塔 C</span>
              <div class="tower" data-index="2"></div>
            </div>
          </div>
          <div class="tower-controls">
            <label>
              ディスク数 <span id="diskCountValue">5</span>
              <input type="range" id="diskCount" min="3" max="7" value="5" />
            </label>
            <label>
              開始塔
              <select id="fromTower">
                <option value="0">A</option>
                <option value="1">B</option>
                <option value="2">C</option>
              </select>
            </label>
            <label>
              移動先
              <select id="toTower">
                <option value="0">A</option>
                <option value="1">B</option>
                <option value="2">C</option>
              </select>
            </label>
          </div>
          <div class="hanoi-actions">
            <button id="moveDisk">手動移動</button>
            <button id="autoSolve">自動で解く</button>
            <button id="resetHanoi">初期状態に戻す</button>
          </div>
      <p class="message" id="hanoiMessage">自由にディスクを移すことで論理の扉を開く。</p>
        </div>
      </section>

      <section id="circleGame" class="panel">
        <h2>円を避ける碁盤の学習対戦</h2>
        <p>
          囲碁の交差点を舞台に、先攻と後攻が交互に石を置いていく。既存の3点が描く円の円周上に
          4点目を置くと失敗。AIは対戦の結果を蓄積しながら、ユーザーの選択を学習していく。
        </p>
        <div class="circle-game">
          <div id="circleBoard" class="circle-board" role="grid" aria-label="円を避けるゲームの碁盤">
            <svg id="circleOverlay" viewBox="0 0 9 9" preserveAspectRatio="xMidYMid meet" aria-hidden="true"></svg>
          </div>
          <div class="circle-game-info">
            <div class="circle-scoreboard">
              <div>
                <strong>あなた</strong>
                <span id="circleHumanScore">0 勝</span>
              </div>
              <div>
                <strong>AI</strong>
                <span id="circleAiScore">0 勝</span>
              </div>
              <div class="circle-scoreboard--wide">
                <strong>引き分け</strong>
                <span id="circleDraws">0 回</span>
              </div>
            </div>
            <div class="circle-controls">
              <label>
                先攻
                <select id="circleFirstPlayer">
                  <option value="human">あなた</option>
                  <option value="ai">AI</option>
                </select>
              </label>
              <button type="button" id="circleReset">盤面をリセット</button>
            </div>
            <p class="circle-message" id="circleMessage">
              線上に4点をつくらないように気をつけながら石を置いてください。
            </p>
            <p class="circle-ai-info" id="circleAiInfo">
              AIは対戦データを蓄積中。初期の探索ではランダムに打つこともあります。
            </p>
          </div>
        </div>
      </section>

      <section id="calcGrid" class="panel calc-grid-panel">
        <h2>計算マスで目標値を狙う</h2>
        <p>
          隣接するマスをクリックしながら演算を受け取り、
          ランダムに提示される目標値を正確に作り上げる。ギブアップすると最短経路が淡い赤で表示される。
        </p>
        <div class="calc-grid-body">
          <div class="calc-grid-board-wrapper">
            <div id="calcGridBoard" class="calc-grid-board" role="grid" aria-label="計算マスの盤面"></div>
            <svg
              id="calcGridOverlay"
              class="calc-grid-overlay"
              viewBox="0 0 12 10"
              preserveAspectRatio="none"
              aria-hidden="true"
            >
              <polyline id="calcPathLine" class="calc-grid-line calc-grid-line--path"></polyline>
              <polyline id="calcSolutionLine" class="calc-grid-line calc-grid-line--solution"></polyline>
            </svg>
          </div>
          <div class="calc-grid-sidebar">
            <div class="calc-grid-stats">
              <div class="calc-stat-card">
                <strong>現在値</strong>
                <span id="calcCurrentValue">1</span>
              </div>
              <div class="calc-stat-card">
                <strong>目標値</strong>
                <span id="calcTargetValue">0</span>
              </div>
              <div class="calc-stat-card">
                <strong>手数</strong>
                <span id="calcStepCount">1</span>
              </div>
              <div class="calc-stat-card">
                <strong>最少手</strong>
                <span id="calcMinSteps">-</span>
              </div>
              <div class="calc-stat-card">
                <strong>スコア</strong>
                <span id="calcScore">0</span>
              </div>
            </div>
            <div class="calc-grid-controls">
              <button id="calcResetBoard" type="button">盤面リセット</button>
              <button id="calcResetPath" type="button">スタートに戻る</button>
              <button id="calcUndoStep" type="button">1手戻す</button>
              <button id="calcGiveUp" type="button">ギブアップ</button>
            </div>
            <p class="calc-grid-message" id="calcGridMessage">
              右や下へ進みながら演算を受け取り、狙った値に到達させましょう。移動は再訪禁止。
            </p>
            <div class="calc-grid-alert" id="calcGridAlert" hidden></div>
            <div class="calc-grid-legend" aria-label="マスの色の凡例">
              <span class="calc-legend-item">
                <span class="calc-legend-box calc-legend-start"></span>スタート
              </span>
              <span class="calc-legend-item">
                <span class="calc-legend-box calc-legend-path"></span>現在の経路
              </span>
              <span class="calc-legend-item">
                <span class="calc-legend-box calc-legend-best"></span>ギブアップ時の最短経路
              </span>
            </div>
            <div class="calc-grid-history">
              <div class="calc-history-section">
                <span class="calc-history-title">現在の軌跡</span>
                <ol id="calcPathHistory" class="calc-history-list" aria-live="polite"></ol>
              </div>
              <div class="calc-history-section">
                <span class="calc-history-title">模範解答</span>
                <ol id="calcSolutionHistory" class="calc-history-list" aria-live="polite"></ol>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section id="aliquot" class="panel">
        <h2>アリコット数列で数の人格を観察する</h2>
        <p>
          与えられた自然数から真の約数（自分自身を除く約数）の和を取り続けると、数はやがて 0 に落ち着いたり、
          完全数・友愛数・社交数のように巡回したりします。下のアニメーションで仕組みを眺めたあと、
          任意の初項で実際に数列を生成してみましょう。
        </p>
        <div class="aliquot-body">
          <div class="aliquot-animation">
            <div class="aliquot-orbit" id="aliquotOrbit" aria-live="polite"></div>
            <div class="aliquot-explanation">
              <p id="aliquotExplanation">真の約数の和をたどると、複雑な軌跡でも必ずどこかへ導かれます。</p>
              <ul id="aliquotDivisors" class="aliquot-divisors"></ul>
            </div>
            <button id="aliquotReplay" class="aliquot-replay" type="button" disabled>アニメーションを再生</button>
          </div>
          <div class="aliquot-controls">
            <form id="aliquotForm" class="aliquot-form">
              <label>
                初項（自然数）
                <input type="number" id="aliquotInput" min="1" step="1" value="12" required />
              </label>
              <button type="submit">数列を生成</button>
              <button type="button" id="aliquotRandom">ランダム</button>
            </form>
            <div id="aliquotStatus" class="aliquot-status">
              初項を入力して「数列を生成」を押すと、収束や巡回の様子が表示されます。
            </div>
            <div class="aliquot-sequence">
              <h3>アリコット数列</h3>
              <ol id="aliquotSequenceList" class="aliquot-sequence-list" aria-live="polite"></ol>
            </div>
            <div class="aliquot-sequence">
              <h3>判定</h3>
              <ul id="aliquotSummaryList" class="aliquot-sequence-list"></ul>
            </div>
          </div>
        </div>
      </section>
    </main>

    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js';

      const overlay = document.getElementById('mathIntroOverlay');
      const canvas = document.getElementById('mathIntroCanvas');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setClearColor(0x01030a, 0);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x02060e, 0.028);

      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1200);
      camera.position.set(0, 0, 32);

      const ambient = new THREE.AmbientLight(0x0b1d36, 1.6);
      scene.add(ambient);
      const pointLight = new THREE.PointLight(0x84fbff, 1.8, 180);
      pointLight.position.set(12, 12, 22);
      scene.add(pointLight);

      const ribbonGroup = new THREE.Group();
      const colors = [0x76f1ff, 0xff76c7, 0xa9f8ff, 0xffb15f];
      for (let i = 0; i < 5; i += 1) {
        const radius = 5.8 - i * 0.5;
        const thickness = 0.22 + i * 0.04;
        const segments = 220;
        const torusKnot = new THREE.TorusKnotGeometry(radius, thickness, segments, 30, 2 + i * 0.3, 3 + i * 0.4);
        const material = new THREE.MeshStandardMaterial({
          color: colors[i % colors.length],
          emissive: 0x090b1e,
          emissiveIntensity: 0.7,
          metalness: 0.8,
          roughness: 0.25,
          transparent: true,
          opacity: 0.88 - i * 0.08,
          side: THREE.DoubleSide,
        });
        const mesh = new THREE.Mesh(torusKnot, material);
        mesh.rotation.x = Math.PI / 2;
        mesh.position.z = -i * 2.6;
        ribbonGroup.add(mesh);
      }
      scene.add(ribbonGroup);

      const haloRing = new THREE.Mesh(
        new THREE.RingGeometry(6.5, 11.5, 96),
        new THREE.MeshBasicMaterial({
          color: 0x4ae1ff,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.2,
        })
      );
      haloRing.rotation.x = Math.PI / 2;
      haloRing.position.z = -16;
      scene.add(haloRing);

      const beamGroup = new THREE.Group();
      const beamMaterial = new THREE.MeshBasicMaterial({ color: 0x70f2ff, transparent: true, opacity: 0.24 });
      for (let i = 0; i < 18; i += 1) {
        const geometry = new THREE.CylinderGeometry(0.02, 0.02, 20, 8, 1, true);
        const beam = new THREE.Mesh(geometry, beamMaterial);
        beam.rotation.z = Math.PI / 2;
        const angle = (i / 18) * Math.PI * 2;
        beam.position.x = Math.cos(angle) * 3.3;
        beam.position.y = Math.sin(angle) * 3.3;
        beam.position.z = -6 - i * 0.5;
        beam.rotation.y = angle;
        beamGroup.add(beam);
      }
      scene.add(beamGroup);

      const trailCount = 780;
      const trailGeometry = new THREE.BufferGeometry();
      const trailPositions = new Float32Array(trailCount * 3);
      for (let i = 0; i < trailCount; i += 1) {
        trailPositions[i * 3] = (Math.random() - 0.5) * 24;
        trailPositions[i * 3 + 1] = (Math.random() - 0.5) * 24;
        trailPositions[i * 3 + 2] = -Math.random() * 40;
      }
      trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      const trailMaterial = new THREE.PointsMaterial({
        color: 0x70ddff,
        size: 0.08,
        transparent: true,
        opacity: 0.95,
      });
      const trails = new THREE.Points(trailGeometry, trailMaterial);
      scene.add(trails);

      const sparkleGeometry = new THREE.SphereGeometry(0.15, 16, 10);
      const sparkleMaterial = new THREE.MeshBasicMaterial({ color: 0xfff1c4 });
      const sparkleGroup = new THREE.Group();
      for (let i = 0; i < 12; i += 1) {
        const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
        sparkle.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, -Math.random() * 30);
        sparkleGroup.add(sparkle);
      }
      scene.add(sparkleGroup);

      const baseZ = 32;
      let running = true;
      const introDuration = 15000;
      const fadeBuffer = 900;

      const updateTrails = (speed) => {
        const positions = trailGeometry.attributes.position.array;
        for (let i = 0; i < trailCount; i += 1) {
          positions[i * 3 + 2] += speed;
          if (positions[i * 3 + 2] > 2) {
            positions[i * 3 + 2] = -38;
            positions[i * 3] = (Math.random() - 0.5) * 24;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 24;
          }
        }
        trailGeometry.attributes.position.needsUpdate = true;
      };

      const updateSparkles = (time) => {
        sparkleGroup.children.forEach((sparkle, idx) => {
          sparkle.position.z += 0.05 + idx * 0.002;
          sparkle.position.y = Math.sin(time * 0.7 + idx) * 2.2;
          if (sparkle.position.z > 2) {
            sparkle.position.z = -35;
            sparkle.position.x = (Math.random() - 0.5) * 10;
          }
        });
      };

      const clock = new THREE.Clock();
      const animate = () => {
        if (!running) return;
        requestAnimationFrame(animate);
        const elapsed = clock.getElapsedTime();
        ribbonGroup.rotation.z += 0.012;
        ribbonGroup.rotation.y = Math.sin(elapsed * 0.8) * 0.3;
        haloRing.rotation.z -= 0.004;
        beamGroup.rotation.y += 0.03;
        updateTrails(0.34);
        updateSparkles(elapsed);
        const travel = Math.min(20, elapsed * 3);
        camera.position.z = baseZ - travel;
        camera.position.y = Math.sin(elapsed * 0.9) * 2.1;
        camera.lookAt(0, 0, -travel * 0.7);
        renderer.render(scene, camera);
        if (elapsed * 1000 > introDuration) {
          hideOverlay(true);
        }
      };

      const handleResize = () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      };
      window.addEventListener('resize', handleResize);

      const hideOverlay = (auto = false) => {
        if (!running) return;
        running = false;
        overlay.classList.add('math-intro-hidden');
        setTimeout(() => {
          overlay.remove();
        }, fadeBuffer);
        if (!auto) {
          setTimeout(() => {
            renderer.forceContextLoss();
          }, fadeBuffer + 200);
        }
      };

      overlay.addEventListener('click', () => hideOverlay());
      setTimeout(() => hideOverlay(true), introDuration + fadeBuffer);

      animate();
    </script>

    <script>
      // Hero mode buttons & table-of-contents dots scroll to sections
      function installScrollLinks(selector) {
        document.querySelectorAll(selector).forEach((button) => {
          button.addEventListener('click', () => {
            const targetId = button.getAttribute('data-target');
            document.getElementById(targetId).scrollIntoView({ behavior: 'smooth' });
          });
        });
      }

      installScrollLinks('.mode-button');
      installScrollLinks('.toc-input');

      const depthRange = document.getElementById('depthRange');
      const angleRange = document.getElementById('angleRange');
      const scaleRange = document.getElementById('scaleRange');
      const branchFactorRange = document.getElementById('branchFactorRange');
      const depthValue = document.getElementById('depthValue');
      const angleValue = document.getElementById('angleValue');
      const scaleValue = document.getElementById('scaleValue');
      const branchCountValue = document.getElementById('branchCountValue');
      const branchColor = document.getElementById('branchColor');
      const fractalTypeSelect = document.getElementById('fractalType');
      const fractalCanvas = document.getElementById('fractalCanvas');
      const ctx = fractalCanvas.getContext('2d');

      const fractalMotion = {
        currentX: 0,
        currentY: 0,
        currentRotation: 0,
        targetX: 0,
        targetY: 0,
        targetRotation: 0,
      };
      let fractalAnimationId;
      let approxInterval;
      let piApproxPointer = 5;
      let eApproxPointer = 5;

      const piDigits =
        '3.14159265358979323846264338327950288419716939937510'
        + '58209749445923078164062862089986280348253421170679';
      const eDigits =
        '2.71828182845904523536028747135266249775724709369995'
        + '95749669676277240766303535475945713821785251664274';
      const piDisplay = document.getElementById('piDigits');
      const eDisplay = document.getElementById('eDigits');
      const piApproxValue = document.getElementById('piApproxValue');
      const eApproxValue = document.getElementById('eApproxValue');
      const piApproxDigits = document.getElementById('piApproxDigits');
      const eApproxDigits = document.getElementById('eApproxDigits');
      const piApproxProgress = document.getElementById('piApproxProgress');
      const eApproxProgress = document.getElementById('eApproxProgress');
      const piIterationLabel = document.getElementById('piIteration');
      const eIterationLabel = document.getElementById('eIteration');
      const piFormulaEl = document.getElementById('piFormula');
      const eFormulaEl = document.getElementById('eFormula');
      const piCaptionEl = document.getElementById('piCaption');
      const eCaptionEl = document.getElementById('eCaption');
      const approxInfo = {
        pi: {
          digits: piDigits,
          formula: 'a_{n+1} = (a_n + b_n)/2, b_{n+1} = sqrt(a_n b_n), t_{n+1} = t_n - p_n(a_n - a_{n+1})^2',
          caption: 'Gauss–Legendre 式はAGM 演算を使い、齊次平均と平方根を交互に計算して桁数を二乗で増やします。',
        },
        e: {
          digits: eDigits,
          formula: 'e = Σ_{k=0}^∞ 1/k!',
          caption: '階乗の逆数を足し合わせるだけで収束するため、CPU はごく少ないステップで多くの桁を確定します。',
        },
      };
      piFormulaEl.textContent = approxInfo.pi.formula;
      eFormulaEl.textContent = approxInfo.e.formula;
      piCaptionEl.textContent = approxInfo.pi.caption;
      eCaptionEl.textContent = approxInfo.e.caption;

      function formatConstantDigits(str) {
        const groupSize = 60;
        const groups = [];
        for (let i = 0; i < str.length; i += groupSize) {
          groups.push(str.slice(i, i + groupSize));
        }
        return groups.join('\n');
      }

      function animateApproximations() {
        piApproxPointer += Math.floor(Math.random() * 3) + 1;
        eApproxPointer += Math.floor(Math.random() * 2) + 1;
        if (piApproxPointer > approxInfo.pi.digits.length) {
          piApproxPointer = 5;
        }
        if (eApproxPointer > approxInfo.e.digits.length) {
          eApproxPointer = 5;
        }
        const piSegment = approxInfo.pi.digits.slice(0, piApproxPointer);
        const eSegment = approxInfo.e.digits.slice(0, eApproxPointer);
        piApproxValue.textContent = piSegment;
        eApproxValue.textContent = eSegment;
        piApproxDigits.textContent = piApproxPointer;
        eApproxDigits.textContent = eApproxPointer;
        piApproxProgress.style.width = `${(piApproxPointer / approxInfo.pi.digits.length) * 100}%`;
        eApproxProgress.style.width = `${(eApproxPointer / approxInfo.e.digits.length) * 100}%`;
        piIterationLabel.textContent = `STEP ${String(Math.min(15, Math.floor(piApproxPointer / 4) + 1)).padStart(2, '0')}`;
        eIterationLabel.textContent = `STEP ${String(Math.min(15, Math.floor(eApproxPointer / 3) + 1)).padStart(2, '0')}`;
      }

      function startApproximationLoop() {
        if (approxInterval) {
          clearInterval(approxInterval);
        }
        animateApproximations();
        approxInterval = setInterval(animateApproximations, 240);
      }

      function updateControlLabels() {
        depthValue.textContent = depthRange.value;
        angleValue.textContent = `${angleRange.value}°`;
        scaleValue.textContent = `${scaleRange.value}%`;
        branchCountValue.textContent = branchFactorRange.value;
      }

      function updateMotionTargets() {
        const scaleNorm = parseFloat(scaleRange.value) / 100;
        const angleInput = parseInt(angleRange.value, 10);
        const branchFactor = parseInt(branchFactorRange.value, 10);
        const fractalType = fractalTypeSelect.value;
        const typeBias = fractalType === 'spiral' ? 1.3 : fractalType === 'triangle' ? 1.0 : 0.75;
        fractalMotion.targetX = (scaleNorm - 0.63) * 210 * typeBias;
        fractalMotion.targetY = (angleInput - 32) * 1.15 * typeBias;
        fractalMotion.targetRotation = (branchFactor - 3) * 0.018 * typeBias;
      }

      function advanceMotion() {
        const smoothing = 0.08;
        fractalMotion.currentX += (fractalMotion.targetX - fractalMotion.currentX) * smoothing;
        fractalMotion.currentY += (fractalMotion.targetY - fractalMotion.currentY) * smoothing;
        fractalMotion.currentRotation +=
          (fractalMotion.targetRotation - fractalMotion.currentRotation) * smoothing;
      }

      function resizeCanvas() {
        const rect = fractalCanvas.getBoundingClientRect();
        fractalCanvas.width = rect.width;
        fractalCanvas.height = rect.height;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }

      function drawBranch(ctx, x, y, length, angle, depth, opts) {
        if (depth === 0 || length < 2) return;
        const x2 = x + Math.cos(angle) * length;
        const y2 = y + Math.sin(angle) * length;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x2, y2);
        ctx.lineWidth = Math.max(1, depth * 1.4);
        ctx.strokeStyle = opts.color;
        ctx.stroke();
        const nextLength = length * (opts.scale * 0.92);
        const children = Math.max(2, opts.branchFactor);
        const baseSpread = opts.branchSpread;
        for (let i = 0; i < children; i += 1) {
          const offset = children === 1 ? 0 : (i / (children - 1) - 0.5);
          const jitter = Math.sin(depth * 0.45 + i) * 0.07;
          const subAngle = angle + offset * baseSpread + offset * jitter;
          drawBranch(ctx, x2, y2, nextLength, subAngle, depth - 1, opts);
        }
      }

      function drawBinaryTree(ctx, opts) {
        const motion = opts.motion || {};
        const offsetX = motion.x || 0;
        const offsetY = motion.y || 0;
        const rotation = motion.rotation || 0;
        ctx.save();
        ctx.translate(opts.width / 2 + offsetX, opts.height * 0.9 + offsetY);
        ctx.rotate(rotation);
        drawBranch(ctx, 0, 0, opts.height * 0.25 * opts.scale, -Math.PI / 2, opts.depth, opts);
        ctx.restore();
      }

      function midpoint(p1, p2) {
        return {
          x: (p1.x + p2.x) / 2,
          y: (p1.y + p2.y) / 2,
        };
      }

      function rotatePoint(x, y, cx, cy, angle) {
        const dx = x - cx;
        const dy = y - cy;
        return {
          x: cx + dx * Math.cos(angle) - dy * Math.sin(angle),
          y: cy + dx * Math.sin(angle) + dy * Math.cos(angle),
        };
      }

      function drawSierpinskiTriangle(ctx, points, depth) {
        if (depth === 0) {
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          ctx.lineTo(points[1].x, points[1].y);
          ctx.lineTo(points[2].x, points[2].y);
          ctx.closePath();
          ctx.fill();
          return;
        }
        const [a, b, c] = points;
        const ab = midpoint(a, b);
        const bc = midpoint(b, c);
        const ac = midpoint(a, c);
        drawSierpinskiTriangle(ctx, [a, ab, ac], depth - 1);
        drawSierpinskiTriangle(ctx, [ab, b, bc], depth - 1);
        drawSierpinskiTriangle(ctx, [ac, bc, c], depth - 1);
      }

      function drawSierpinski(ctx, opts) {
        const { width, height, depth, color, scale, bias } = opts;
        const motion = opts.motion || {};
        const offsetX = motion.x || 0;
        const offsetY = motion.y || 0;
        const rotation = motion.rotation || 0;
        const radius = Math.min(width, height) * (0.25 + scale * 0.22);
        const points = [
          { x: 0, y: -radius },
          { x: -radius, y: radius },
          { x: radius, y: radius },
        ].map((point) => rotatePoint(point.x, point.y, 0, 0, bias * 0.65));
        ctx.save();
        ctx.translate(width / 2 + offsetX, height * 0.55 + offsetY);
        ctx.rotate(rotation);
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.5;
        drawSierpinskiTriangle(ctx, points, Math.min(depth, 8));
        ctx.restore();
      }

      function drawSpiral(ctx, opts) {
        const { width, height, depth, scale, color, sliderAngle, branchFactor } = opts;
        const motion = opts.motion || {};
        const offsetX = motion.x || 0;
        const offsetY = motion.y || 0;
        const rotation = motion.rotation || 0;
        ctx.save();
        ctx.translate(width / 2 + offsetX, height / 2 + offsetY);
        ctx.rotate(rotation);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.2;
        const previousShadowBlur = ctx.shadowBlur;
        const previousShadowColor = ctx.shadowColor;
        ctx.shadowBlur = 16;
        ctx.shadowColor = color;
        let x = 0;
        let y = 0;
        const margin = Math.min(width, height) * 0.08;
        const maxLength = Math.max(
          22,
          Math.min(width, height) * (0.38 + Math.min(scale, 0.75) * 0.25) - margin
        );
        let length = maxLength;
        let currentAngle = sliderAngle;
        const shrink = 0.915 - Math.min(scale, 0.7) * 0.12;
        const steps = depth * 10 + branchFactor * 4;
        for (let step = 0; step < steps && length > 3; step += 1) {
          const nextX = x + Math.cos(currentAngle) * length;
          const nextY = y + Math.sin(currentAngle) * length;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(nextX, nextY);
          ctx.stroke();
          x = nextX;
          y = nextY;
          length *= shrink;
          currentAngle +=
            (Math.PI / (22 + step)) + (branchFactor * 0.02) + Math.sin(step * 0.2) * 0.04;
          if (Math.abs(x) > width / 2 - margin || Math.abs(y) > height / 2 - margin) {
            length *= 0.85;
            currentAngle += 0.08;
          }
        }
        ctx.shadowBlur = previousShadowBlur;
        ctx.shadowColor = previousShadowColor;
        ctx.restore();
      }

      const fractalDrawers = {
        tree: drawBinaryTree,
        triangle: drawSierpinski,
        spiral: drawSpiral,
      };

      function renderFractal() {
        const width = fractalCanvas.width;
        const height = fractalCanvas.height;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = 'rgba(1, 2, 5, 0.65)';
        ctx.fillRect(0, 0, width, height);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        advanceMotion();
        const scaleFactor = Math.max(0.2, parseFloat(scaleRange.value) / 100);
        const branchFactor = parseInt(branchFactorRange.value, 10);
        const branchSpread = Math.PI * (0.35 + branchFactor * 0.08);
        const sliderAngle = (parseInt(angleRange.value, 10) * Math.PI) / 180;
        const depthValueInput = parseInt(depthRange.value, 10);
        const fractalType = fractalTypeSelect.value;
        const options = {
          width,
          height,
          depth: fractalType === 'triangle' ? Math.min(depthValueInput, 7) : depthValueInput,
          scale: scaleFactor,
          color: branchColor.value,
          sliderAngle,
          branchFactor,
          branchSpread,
          bias: Math.cos(branchFactor * 0.35),
          motion: {
            x: fractalMotion.currentX,
            y: fractalMotion.currentY,
            rotation: fractalMotion.currentRotation,
          },
        };
        fractalDrawers[fractalType](ctx, options);
      }

      function startFractalLoop() {
        if (fractalAnimationId) {
          cancelAnimationFrame(fractalAnimationId);
        }
        const loop = () => {
          renderFractal();
          fractalAnimationId = requestAnimationFrame(loop);
        };
        fractalAnimationId = requestAnimationFrame(loop);
      }

      function initializeFractal() {
        updateControlLabels();
        updateMotionTargets();
        resizeCanvas();
        renderFractal();
      }

      const controlElements = [
        depthRange,
        angleRange,
        scaleRange,
        branchFactorRange,
        fractalTypeSelect,
      ];

      controlElements.forEach((element) => {
        element.addEventListener('input', () => {
          updateControlLabels();
          updateMotionTargets();
          renderFractal();
        });
      });

      branchColor.addEventListener('input', renderFractal);

      window.addEventListener('resize', () => {
        resizeCanvas();
        renderFractal();
      });

      piDisplay.textContent = formatConstantDigits(piDigits);
      eDisplay.textContent = formatConstantDigits(eDigits);
      initializeFractal();
      startFractalLoop();
      startApproximationLoop();

      // Hanoi towers
      const diskCountInput = document.getElementById('diskCount');
      const diskCountValue = document.getElementById('diskCountValue');
      const fromSelect = document.getElementById('fromTower');
      const toSelect = document.getElementById('toTower');
      const moveButton = document.getElementById('moveDisk');
      const autoSolveButton = document.getElementById('autoSolve');
      const resetButton = document.getElementById('resetHanoi');
      const messageEl = document.getElementById('hanoiMessage');
      const towerEls = document.querySelectorAll('.tower');
      let towers = [[], [], []];
      let diskCount = parseInt(diskCountInput.value, 10);
      let autoTimer;
      let dragOrigin = null;

      function createDisks(count) {
        const stack = [];
        for (let i = count; i >= 1; i -= 1) {
          stack.push(i);
        }
        return stack;
      }

      function renderHanoi() {
        towerEls.forEach((towerEl) => {
          const idx = Number(towerEl.dataset.index);
        towerEl.innerHTML = '';
          const stack = towers[idx] || [];
          const ordered = [...stack].sort((a, b) => b - a);
          ordered.forEach((diskSize) => {
            const disk = document.createElement('div');
            disk.className = 'disk';
            const widthRatio = (diskSize / diskCount) * 0.7 + 0.3;
            disk.style.width = `${widthRatio * 100}%`;
            disk.style.background = `linear-gradient(90deg, rgba(0,255,255,0.4), rgba(255,0,255,0.4))`;
            disk.style.order = diskSize;
            towerEl.appendChild(disk);
          });
        });
      }

      function setMessage(text) {
        messageEl.textContent = text;
      }

      function resetHanoi() {
        clearDragHighlight();
        if (autoTimer) {
          clearInterval(autoTimer);
          autoTimer = null;
        }
        diskCount = parseInt(diskCountInput.value, 10);
        diskCountValue.textContent = diskCount;
        towers = [createDisks(diskCount), [], []];
        renderHanoi();
        setMessage(`ディスク数 ${diskCount} で初期化されました。`);
      }

      function moveDisk(from, to, silent = false) {
        if (from === to) {
          if (!silent) setMessage('異なる塔を選んでください。');
          return false;
        }
        const source = towers[from];
        const target = towers[to];
        if (source.length === 0) {
          if (!silent) setMessage('開始塔にディスクがありません。');
          return false;
        }
        const disk = source[source.length - 1];
        const targetTop = target[target.length - 1];
        if (targetTop && disk > targetTop) {
          if (!silent) setMessage('大きなディスクを小さなディスクの上に置けません。');
          return false;
        }
        target.push(source.pop());
        renderHanoi();
        if (!silent) setMessage(`塔 ${String.fromCharCode(65 + from)} -> ${String.fromCharCode(65 + to)} に移動しました。`);
        return true;
      }

      function solveHanoi(n, from, to, aux, moves) {
        if (n === 0) return;
        solveHanoi(n - 1, from, aux, to, moves);
        moves.push([from, to]);
        solveHanoi(n - 1, aux, to, from, moves);
      }

      diskCountInput.addEventListener('input', () => {
        diskCountValue.textContent = diskCountInput.value;
      });

      function clearDragHighlight() {
        dragOrigin = null;
        towerEls.forEach((el) => {
          el.classList.remove('tower-drag-source', 'tower-drag-target');
        });
      }

      towerEls.forEach((towerEl) => {
        towerEl.addEventListener('pointerdown', (event) => {
          event.preventDefault();
          const idx = Number(towerEl.dataset.index);
          if (towers[idx].length === 0) {
            setMessage('この塔にディスクがありません。');
            return;
          }
          dragOrigin = idx;
          towerEl.classList.add('tower-drag-source');
          setMessage(`塔 ${String.fromCharCode(65 + idx)} からドラッグを開始しました。`);
        });
        towerEl.addEventListener('pointerenter', () => {
          if (dragOrigin === null) return;
          const idx = Number(towerEl.dataset.index);
          if (idx !== dragOrigin) {
            towerEl.classList.add('tower-drag-target');
          }
        });
        towerEl.addEventListener('pointerleave', () => {
          towerEl.classList.remove('tower-drag-target');
        });
        towerEl.addEventListener('pointerup', () => {
          if (dragOrigin === null) return;
          const target = Number(towerEl.dataset.index);
          if (target !== dragOrigin) {
            moveDisk(dragOrigin, target);
          } else {
            setMessage('同じ塔には戻せません。');
          }
          clearDragHighlight();
        });
      });

      document.addEventListener('pointerup', (event) => {
        if (dragOrigin === null) return;
        if (!event.target.closest('.tower')) {
          clearDragHighlight();
          setMessage('ドラッグをキャンセルしました。');
        }
      });

      moveButton.addEventListener('click', () => {
        const from = Number(fromSelect.value);
        const to = Number(toSelect.value);
        moveDisk(from, to);
      });

      autoSolveButton.addEventListener('click', () => {
        if (autoTimer) {
          clearInterval(autoTimer);
        }
        const moves = [];
        solveHanoi(diskCount, 0, 2, 1, moves);
        let index = 0;
        autoSolveButton.disabled = true;
        setMessage('自動解答を開始します。');
        autoTimer = setInterval(() => {
          if (index >= moves.length) {
            clearInterval(autoTimer);
            autoTimer = null;
            autoSolveButton.disabled = false;
            setMessage('自動解答が完了しました。');
            return;
          }
          const [from, to] = moves[index];
          moveDisk(from, to, true);
          index += 1;
        }, 420);
      });

      resetButton.addEventListener('click', () => {
        resetHanoi();
      });

      // Circle avoidance game
      const circleBoard = document.getElementById('circleBoard');
      const circleMessage = document.getElementById('circleMessage');
      const circleAiInfo = document.getElementById('circleAiInfo');
      const circleHumanScoreEl = document.getElementById('circleHumanScore');
      const circleAiScoreEl = document.getElementById('circleAiScore');
      const circleDrawsEl = document.getElementById('circleDraws');
      const circleFirstPlayer = document.getElementById('circleFirstPlayer');
      const circleResetButton = document.getElementById('circleReset');
      const circleOverlay = document.getElementById('circleOverlay');
      const circleBoardSize = 9;
      const circleCells = [];
      let circleBoardState = [];
      let circleCurrentPlayer = 1;
      let circleGameOver = false;
      let circleLastMove = null;
      let circleAiTimer = null;
      let circleHumanWins = 0;
      let circleAiWins = 0;
      let circleDrawGames = 0;
      let circleAiMoves = [];
      const circleExperience = loadCircleExperience();

      function loadCircleExperience() {
        try {
          const stored = localStorage.getItem('circleAvoidAI');
          return stored ? JSON.parse(stored) : {};
        } catch (error) {
          return {};
        }
      }

      function saveCircleExperience() {
        try {
          localStorage.setItem('circleAvoidAI', JSON.stringify(circleExperience));
        } catch (error) {
          // ignore storage failures
        }
      }

      function updateAiStatsDisplay() {
        const entries = Object.values(circleExperience);
        const total = entries.reduce((sum, entry) => sum + entry.total, 0);
        const wins = entries.reduce((sum, entry) => sum + entry.wins, 0);
        const rate = total ? Math.round((wins / total) * 100) : 0;
        circleAiInfo.textContent = `学習エントリ ${entries.length} 件 / 勝率 ${rate}% / 訓練 ${total} 回`;
      }

      function buildCircleCells() {
        circleCells.length = 0;
        circleBoard.innerHTML = '';
        for (let row = 0; row < circleBoardSize; row += 1) {
          const rowCells = [];
          for (let col = 0; col < circleBoardSize; col += 1) {
            const cell = document.createElement('button');
            cell.type = 'button';
            cell.className = 'circle-cell';
            cell.dataset.row = row;
            cell.dataset.col = col;
            cell.dataset.player = '0';
            const stone = document.createElement('span');
            stone.className = 'stone';
            cell.appendChild(stone);
            cell.addEventListener('click', () => handleCircleClick(row, col));
            circleBoard.appendChild(cell);
            rowCells.push(cell);
          }
          circleCells.push(rowCells);
        }
      }

      function resetCircleGame() {
        if (circleAiTimer) {
          clearTimeout(circleAiTimer);
          circleAiTimer = null;
        }
        circleAiMoves = [];
        circleGameOver = false;
        circleBoardState = Array.from({ length: circleBoardSize }, () =>
          Array.from({ length: circleBoardSize }, () => 0)
        );
        circleLastMove = null;
        circleCurrentPlayer = circleFirstPlayer.value === 'ai' ? 2 : 1;
        renderCircleBoard();
        circleMessage.textContent =
          circleCurrentPlayer === 2
            ? 'AIが先手で形を探ります…'
            : 'あなたから打ち始めます。';
        if (circleCurrentPlayer === 2) {
          scheduleAiTurn();
        }
      }

      function updateScoreboard() {
        circleHumanScoreEl.textContent = `${circleHumanWins} 勝`;
        circleAiScoreEl.textContent = `${circleAiWins} 勝`;
        circleDrawsEl.textContent = `${circleDrawGames} 回`;
      }

      function renderCircleBoard() {
        circleBoardState.forEach((row, rowIndex) => {
          row.forEach((value, colIndex) => {
            const cell = circleCells[rowIndex][colIndex];
            cell.dataset.player = String(value);
            const isLast =
              circleLastMove &&
              circleLastMove.row === rowIndex &&
              circleLastMove.col === colIndex;
            cell.classList.toggle('circle-cell--last', Boolean(isLast));
          });
        });
        updateCircleOverlay();
      }

      function updateCircleOverlay() {
        if (!circleOverlay) return;
        const points = [];
        for (let r = 0; r < circleBoardSize; r += 1) {
          for (let c = 0; c < circleBoardSize; c += 1) {
            if (circleBoardState[r][c]) {
              points.push({ x: c, y: r });
            }
          }
        }
        if (points.length < 3) {
          circleOverlay.innerHTML = '';
          return;
        }
        const seen = new Set();
        const circles = [];
        outer: for (let i = 0; i < points.length - 2; i += 1) {
          for (let j = i + 1; j < points.length - 1; j += 1) {
            for (let k = j + 1; k < points.length; k += 1) {
              const circle = computeCircle(points[i], points[j], points[k]);
              if (!circle) continue;
              if (circle.radius > circleBoardSize * 1.5) continue;
              const key = `${circle.center.x.toFixed(2)}|${circle.center.y.toFixed(2)}|${circle.radius.toFixed(2)}`;
              if (seen.has(key)) continue;
              seen.add(key);
              circles.push(circle);
              if (circles.length >= 6) {
                break outer;
              }
            }
          }
        }
        circleOverlay.innerHTML = circles
          .map(
            (circle) =>
              `<circle cx="${(circle.center.x + 0.5).toFixed(3)}" cy="${(
                circle.center.y + 0.5
              ).toFixed(3)}" r="${circle.radius.toFixed(3)}" stroke="rgba(255,255,255,0.6)" stroke-width="0.04" fill="none" />`
          )
          .join('');
      }

      function isBoardFull() {
        return circleBoardState.every((row) => row.every((cell) => cell !== 0));
      }

      function getBoardKey() {
        return circleBoardState.map((row) => row.join('')).join('|');
      }

      function chooseAiMove(stateKey) {
        const empties = [];
        for (let row = 0; row < circleBoardSize; row += 1) {
          for (let col = 0; col < circleBoardSize; col += 1) {
            if (circleBoardState[row][col] === 0) {
              const move = { row, col };
              const loses = checkCircleLoss(row, col);
              empties.push({ ...move, loses });
            }
          }
        }
        if (empties.length === 0) return null;
        const safeMoves = empties.filter((option) => !option.loses);
        const candidates = safeMoves.length ? safeMoves : empties;
        if (Math.random() < 0.2) {
          const pick = candidates[Math.floor(Math.random() * candidates.length)];
          return { row: pick.row, col: pick.col, moveKey: `${stateKey}|${pick.row},${pick.col}` };
        }
        let best = null;
        let bestScore = -Infinity;
        const centerCoord = (circleBoardSize - 1) / 2;
        candidates.forEach((move) => {
          const moveKey = `${stateKey}|${move.row},${move.col}`;
          const record = circleExperience[moveKey];
          const baseRate = record && record.total ? record.wins / record.total : 0.33;
          const novelty = 1 - Math.min(1, (record?.total ?? 0) / 10);
          const distanceScore =
            -Math.hypot(move.row - centerCoord, move.col - centerCoord) * 0.035;
          const score = baseRate + novelty * 0.18 + distanceScore;
          if (score > bestScore) {
            bestScore = score;
            best = { row: move.row, col: move.col, moveKey };
          }
        });
        if (!best) {
          const fallback = candidates[Math.floor(Math.random() * candidates.length)];
          return { row: fallback.row, col: fallback.col, moveKey: `${stateKey}|${fallback.row},${fallback.col}` };
        }
        return best;
      }

      function scheduleAiTurn() {
        if (circleGameOver) return;
        if (circleAiTimer) {
          clearTimeout(circleAiTimer);
          circleAiTimer = null;
        }
        circleMessage.textContent = 'AIが読みを進めています…';
        circleAiTimer = setTimeout(() => {
          circleAiTimer = null;
          if (circleGameOver) return;
          const stateKey = getBoardKey();
          const move = chooseAiMove(stateKey);
          if (!move) {
            finalizeCircleGame('draw', 'これ以上打てる場所がありません。');
            return;
          }
          circleAiMoves.push(move.moveKey);
          makeCircleMove(move.row, move.col, 2);
        }, 560);
      }

      function finalizeCircleGame(outcome, message) {
        circleGameOver = true;
        if (circleAiTimer) {
          clearTimeout(circleAiTimer);
          circleAiTimer = null;
        }
        if (outcome === 'human') {
          circleHumanWins += 1;
        } else if (outcome === 'ai') {
          circleAiWins += 1;
        } else {
          circleDrawGames += 1;
        }
        updateScoreboard();
        circleMessage.textContent = message;
        learnFromExperience(outcome === 'ai');
      }

      function learnFromExperience(aiWon) {
        if (!circleAiMoves.length) {
          updateAiStatsDisplay();
          return;
        }
        circleAiMoves.forEach((moveKey) => {
          const record = circleExperience[moveKey] || { wins: 0, total: 0 };
          record.total += 1;
          if (aiWon) {
            record.wins += 1;
          }
          circleExperience[moveKey] = record;
        });
        circleAiMoves = [];
        saveCircleExperience();
        updateAiStatsDisplay();
      }

      function makeCircleMove(row, col, player) {
        const loses = checkCircleLoss(row, col);
        circleBoardState[row][col] = player;
        circleLastMove = { row, col };
        renderCircleBoard();
        if (loses) {
          const winner = player === 1 ? 'ai' : 'human';
          const reason =
            player === 1
              ? 'あなたは円の円周上に4点を作ってしまいました。'
              : 'AIが円上に4点を置いてしまいました。';
          finalizeCircleGame(winner, reason);
          return;
        }
        if (isBoardFull()) {
          finalizeCircleGame('draw', '盤面がすべて埋まりました。');
          return;
        }
        circleCurrentPlayer = player === 1 ? 2 : 1;
        circleMessage.textContent =
          circleCurrentPlayer === 2
            ? 'AIの番です。'
            : 'あなたの番です。円上の4点を避けてください。';
        if (circleCurrentPlayer === 2) {
          scheduleAiTurn();
        }
      }

      function handleCircleClick(row, col) {
        if (circleGameOver || circleCurrentPlayer !== 1) {
          return;
        }
        if (circleBoardState[row][col] !== 0) {
          circleMessage.textContent = 'そこにはすでに石があります。';
          return;
        }
        makeCircleMove(row, col, 1);
      }

      function checkCircleLoss(row, col) {
        const existingStones = [];
        for (let r = 0; r < circleBoardSize; r += 1) {
          for (let c = 0; c < circleBoardSize; c += 1) {
            if (circleBoardState[r][c]) {
              existingStones.push({ x: c, y: r });
            }
          }
        }
        if (existingStones.length < 3) return false;
        const newPoint = { x: col, y: row };
        const tolerance = 0.04;
        for (let i = 0; i < existingStones.length - 2; i += 1) {
          for (let j = i + 1; j < existingStones.length - 1; j += 1) {
            for (let k = j + 1; k < existingStones.length; k += 1) {
              const circle = computeCircle(existingStones[i], existingStones[j], existingStones[k]);
              if (!circle) continue;
              const diff = Math.abs(distance(circle.center, newPoint) - circle.radius);
              if (diff < tolerance) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function computeCircle(p1, p2, p3) {
        const d =
          2 *
          (p1.x * (p2.y - p3.y) +
            p2.x * (p3.y - p1.y) +
            p3.x * (p1.y - p2.y));
        if (Math.abs(d) < 1e-6) return null;
        const aSq = p1.x * p1.x + p1.y * p1.y;
        const bSq = p2.x * p2.x + p2.y * p2.y;
        const cSq = p3.x * p3.x + p3.y * p3.y;
        const ux =
          (aSq * (p2.y - p3.y) + bSq * (p3.y - p1.y) + cSq * (p1.y - p2.y)) / d;
        const uy =
          (aSq * (p3.x - p2.x) + bSq * (p1.x - p3.x) + cSq * (p2.x - p1.x)) / d;
        const center = { x: ux, y: uy };
        const radius = distance(center, p1);
        return Number.isFinite(radius) ? { center, radius } : null;
      }

      function distance(p1, p2) {
        return Math.hypot(p1.x - p2.x, p1.y - p2.y);
      }

      circleFirstPlayer.addEventListener('change', resetCircleGame);
      circleResetButton.addEventListener('click', resetCircleGame);
      buildCircleCells();
      updateScoreboard();
      updateAiStatsDisplay();
      resetCircleGame();

      // Calculation grid game
      const calcGridBoard = document.getElementById('calcGridBoard');
      const calcMessageEl = document.getElementById('calcGridMessage');
      const calcAlertEl = document.getElementById('calcGridAlert');
      const calcCurrentValueEl = document.getElementById('calcCurrentValue');
      const calcTargetValueEl = document.getElementById('calcTargetValue');
      const calcStepCountEl = document.getElementById('calcStepCount');
      const calcMinStepsEl = document.getElementById('calcMinSteps');
      const calcScoreEl = document.getElementById('calcScore');
      const calcResetBoardButton = document.getElementById('calcResetBoard');
      const calcResetPathButton = document.getElementById('calcResetPath');
      const calcUndoButton = document.getElementById('calcUndoStep');
      const calcGiveUpButton = document.getElementById('calcGiveUp');
      const calcPathHistoryEl = document.getElementById('calcPathHistory');
      const calcSolutionHistoryEl = document.getElementById('calcSolutionHistory');
      const calcGridOverlay = document.getElementById('calcGridOverlay');
      const calcPathLine = document.getElementById('calcPathLine');
      const calcSolutionLine = document.getElementById('calcSolutionLine');

      const calcConfig = {
        width: 12,
        height: 10,
        minTarget: 10,
        maxTarget: 1000,
        multipliers: [-4, -3, -2, -1, 1, 2, 3, 4],
      };

      const calcState = {
        grid: [],
        path: [],
        currentValue: 1,
        target: 0,
        score: 0,
        minSteps: null,
        stageClear: false,
        gaveUp: false,
        shortestPath: [],
        history: [],
      };

      function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function generateCalcGrid() {
        const grid = [];
        for (let y = 0; y < calcConfig.height; y += 1) {
          const row = [];
          for (let x = 0; x < calcConfig.width; x += 1) {
            if (y === 0 && x === 0) {
              row.push('1');
            } else {
              const operators = ['+', '-', '*'];
              const op = operators[Math.floor(Math.random() * operators.length)];
              if (op === '*') {
                const num = calcConfig.multipliers[Math.floor(Math.random() * calcConfig.multipliers.length)];
                row.push(`*${num}`);
              } else {
                const num = randomInt(1, 9);
                row.push(`${op}${num}`);
              }
            }
          }
          grid.push(row);
        }
        return grid;
      }

      function displayCalcOperation(opStr) {
        return opStr.replace('*', '×');
      }

      function applyCalcOperation(value, operation) {
        if (operation === '1') return value;
        const op = operation[0];
        const num = Number(operation.slice(1));
        if (op === '+') return value + num;
        if (op === '-') return value - num;
        if (op === '*') return value * num;
        return value;
      }

      function calculateCalcScore(playerSteps, minSteps) {
        if (typeof minSteps !== 'number') return 0;
        const diff = playerSteps - minSteps;
        return Math.max(0, 100 - diff * 10);
      }

      function formatCalcCoordinate(row, col) {
        const rowLabel = String.fromCharCode(65 + row);
        return `${rowLabel}${col + 1}`;
      }

      function updateCalcHistoryList() {
        calcPathHistoryEl.innerHTML = '';
        if (!calcState.history.length) {
          const placeholder = document.createElement('li');
          placeholder.className = 'calc-history-empty';
          placeholder.textContent = 'まだ移動していません。';
          calcPathHistoryEl.appendChild(placeholder);
          return;
        }
        calcState.history.forEach((entry, index) => {
          const li = document.createElement('li');
          const label = document.createElement('span');
          label.textContent = `${index + 1}. ${formatCalcCoordinate(entry.coord[0], entry.coord[1])}`;
          const detail = document.createElement('span');
          detail.textContent =
            entry.op === '1'
              ? `開始 → ${entry.value}`
              : `${displayCalcOperation(entry.op)} → ${entry.value}`;
          li.appendChild(label);
          li.appendChild(detail);
          calcPathHistoryEl.appendChild(li);
        });
      }

      function updateCalcSolutionList() {
        calcSolutionHistoryEl.innerHTML = '';
        if (!calcState.gaveUp) {
          const placeholder = document.createElement('li');
          placeholder.className = 'calc-history-empty';
          placeholder.textContent = 'ギブアップすると模範経路が表示されます。';
          calcSolutionHistoryEl.appendChild(placeholder);
          return;
        }
        if (!calcState.shortestPath.length) {
          const placeholder = document.createElement('li');
          placeholder.className = 'calc-history-empty';
          placeholder.textContent = 'この目標値に達するルートは見つかりませんでした。';
          calcSolutionHistoryEl.appendChild(placeholder);
          return;
        }
        let value = 1;
        calcState.shortestPath.forEach(([row, col], index) => {
          const li = document.createElement('li');
          const label = document.createElement('span');
          label.textContent = `${index + 1}. ${formatCalcCoordinate(row, col)}`;
          const detail = document.createElement('span');
          if (index === 0) {
            detail.textContent = '開始 → 1';
          } else {
            const op = calcState.grid[row][col];
            value = applyCalcOperation(value, op);
            detail.textContent = `${displayCalcOperation(op)} → ${value}`;
          }
          li.appendChild(label);
          li.appendChild(detail);
          calcSolutionHistoryEl.appendChild(li);
        });
      }

      function syncCalcValueAndHistory() {
        const history = [];
        let value = 1;
        calcState.path.forEach(([row, col], index) => {
          if (index === 0) {
            history.push({ coord: [row, col], op: '1', value: 1 });
            return;
          }
          const op = calcState.grid[row][col];
          value = applyCalcOperation(value, op);
          history.push({ coord: [row, col], op, value });
        });
        calcState.currentValue = value;
        calcState.history = history;
        updateCalcHistoryList();
      }

      function findCalcMinSteps(grid, target) {
        const queue = [{ pos: [0, 0], value: 1, path: [[0, 0]] }];
        let head = 0;
        while (head < queue.length) {
          const current = queue[head];
          head += 1;
          const [y, x] = current.pos;
          if (current.value === target) {
            return current.path.length;
          }
          const candidates = [
            [y, x + 1],
            [y + 1, x],
            [y, x - 1],
            [y - 1, x],
          ];
          candidates.forEach(([ny, nx]) => {
            if (ny < 0 || ny >= calcConfig.height || nx < 0 || nx >= calcConfig.width) return;
            if (current.path.some(([py, px]) => py === ny && px === nx)) return;
            const nextValue = applyCalcOperation(current.value, grid[ny][nx]);
            queue.push({
              pos: [ny, nx],
              value: nextValue,
              path: current.path.concat([[ny, nx]]),
            });
          });
        }
        return null;
      }

      function findCalcMinPath(grid, target) {
        const queue = [{ pos: [0, 0], value: 1, path: [[0, 0]] }];
        let head = 0;
        while (head < queue.length) {
          const current = queue[head];
          head += 1;
          const [y, x] = current.pos;
          if (current.value === target) {
            return current.path;
          }
          const candidates = [
            [y, x + 1],
            [y + 1, x],
            [y, x - 1],
            [y - 1, x],
          ];
          candidates.forEach(([ny, nx]) => {
            if (ny < 0 || ny >= calcConfig.height || nx < 0 || nx >= calcConfig.width) return;
            if (current.path.some(([py, px]) => py === ny && px === nx)) return;
            const nextValue = applyCalcOperation(current.value, grid[ny][nx]);
            queue.push({
              pos: [ny, nx],
              value: nextValue,
              path: current.path.concat([[ny, nx]]),
            });
          });
        }
        return [];
      }

      function setCalcMessage(text) {
        calcMessageEl.textContent = text;
      }

      function showCalcAlert(text) {
        calcAlertEl.textContent = text;
        calcAlertEl.hidden = false;
      }

      function hideCalcAlert() {
        calcAlertEl.hidden = true;
        calcAlertEl.textContent = '';
      }

      function updateCalcHud() {
        calcCurrentValueEl.textContent = calcState.currentValue;
        calcTargetValueEl.textContent = calcState.target;
        calcStepCountEl.textContent = calcState.path.length;
        calcMinStepsEl.textContent = typeof calcState.minSteps === 'number' ? calcState.minSteps : '未到達';
        calcScoreEl.textContent = calcState.score;
        calcUndoButton.disabled = calcState.path.length <= 1 || calcState.stageClear || calcState.gaveUp;
        calcGiveUpButton.disabled = calcState.stageClear || calcState.gaveUp;
      }

      function renderCalcGrid() {
        if (!calcState.grid.length) {
          calcGridBoard.innerHTML = '';
          updateCalcOverlay();
          return;
        }
        const fragment = document.createDocumentFragment();
        const pathSet = new Set();
        const pathStepMap = new Map();
        calcState.path.forEach(([py, px], index) => {
          const key = `${py}-${px}`;
          pathSet.add(key);
          pathStepMap.set(key, index + 1);
        });
        const shortestSet = new Set(
          calcState.shortestPath.map(([py, px]) => `${py}-${px}`)
        );
        const solutionStepMap = new Map();
        calcState.shortestPath.forEach(([py, px], index) => {
          solutionStepMap.set(`${py}-${px}`, index + 1);
        });
        calcState.grid.forEach((row, y) => {
          row.forEach((cell, x) => {
            const button = document.createElement('button');
            button.type = 'button';
            button.textContent = displayCalcOperation(cell);
            button.dataset.row = String(y);
            button.dataset.col = String(x);
            const key = `${y}-${x}`;
            if (y === 0 && x === 0) {
              button.classList.add('calc-cell-start');
            }
            if (pathSet.has(key)) {
              button.classList.add('calc-cell-path');
              button.dataset.step = String(pathStepMap.get(key));
            }
            if (calcState.gaveUp && shortestSet.has(key)) {
              button.classList.add('calc-cell-best');
              button.dataset.solutionStep = String(solutionStepMap.get(key));
            }
            if (calcState.stageClear || calcState.gaveUp) {
              button.disabled = true;
            }
            fragment.appendChild(button);
          });
        });
        calcGridBoard.innerHTML = '';
        calcGridBoard.appendChild(fragment);
        updateCalcOverlay();
      }

      function updateCalcOverlay() {
        if (!calcPathLine || !calcSolutionLine) return;
        const pathPoints = calcState.path
          .map(([row, col]) => `${col + 0.5},${row + 0.5}`)
          .join(' ');
        calcPathLine.setAttribute('points', pathPoints);
        if (calcState.gaveUp && calcState.shortestPath.length) {
          const solutionPoints = calcState.shortestPath
            .map(([row, col]) => `${col + 0.5},${row + 0.5}`)
            .join(' ');
          calcSolutionLine.setAttribute('points', solutionPoints);
        } else {
          calcSolutionLine.setAttribute('points', '');
        }
      }

      function resetCalcGame(fullReset = true) {
        if (fullReset || !calcState.grid.length) {
          calcState.grid = generateCalcGrid();
          calcState.target = randomInt(calcConfig.minTarget, calcConfig.maxTarget);
          calcState.minSteps = findCalcMinSteps(calcState.grid, calcState.target);
        }
        calcState.path = [[0, 0]];
        calcState.score = calculateCalcScore(calcState.path.length, calcState.minSteps);
        calcState.stageClear = false;
        calcState.gaveUp = false;
        calcState.shortestPath = [];
        calcState.history = [];
        hideCalcAlert();
        syncCalcValueAndHistory();
        updateCalcSolutionList();
        renderCalcGrid();
        updateCalcHud();
        setCalcMessage(
          fullReset
            ? '新しい盤面を生成しました。上下左右に1マスだけ移動できます。'
            : 'スタート地点に戻りました。隣接するマスだけ辿れます。'
        );
      }

      function handleCalcCellClick(row, col) {
        if (calcState.stageClear) {
          setCalcMessage('目標値に到達済みです。盤面をリセットして次のステージへ。');
          return;
        }
        if (calcState.gaveUp) {
          setCalcMessage('ギブアップ中です。盤面をリセットして再挑戦してください。');
          return;
        }
        const last = calcState.path[calcState.path.length - 1];
        const isAdjacent = Math.abs(row - last[0]) + Math.abs(col - last[1]) === 1;
        const alreadyVisited = calcState.path.some(([py, px]) => py === row && px === col);
        if (alreadyVisited) {
          setCalcMessage('同じマスへは戻れません。別の方向を選びましょう。');
          return;
        }
        if (!isAdjacent) {
          setCalcMessage('移動できるのは上下左右に隣接したマスだけです。');
          return;
        }
        calcState.path.push([row, col]);
        syncCalcValueAndHistory();
        calcState.score = calculateCalcScore(calcState.path.length, calcState.minSteps);
        const reachedTarget = calcState.currentValue === calcState.target;
        if (reachedTarget) {
          calcState.stageClear = true;
        }
        renderCalcGrid();
        updateCalcHud();
        if (reachedTarget) {
          showCalcAlert('🎉 目標値に到達しました。盤面リセットで次のステージへ進めます。');
          setCalcMessage('おめでとうございます！ピッタリ同じ値になりました。');
        } else {
          setCalcMessage(`現在値は ${calcState.currentValue}。引き続き目標 ${calcState.target} を目指しましょう。`);
        }
      }

      function undoCalcStep() {
        if (calcState.stageClear) {
          setCalcMessage('クリア済みです。盤面またはスタートに戻して再挑戦してください。');
          return;
        }
        if (calcState.gaveUp) {
          setCalcMessage('ギブアップ中は巻き戻せません。盤面をリセットしてください。');
          return;
        }
        if (calcState.path.length <= 1) {
          setCalcMessage('スタート地点からは戻せません。');
          return;
        }
        calcState.path.pop();
        syncCalcValueAndHistory();
        calcState.score = calculateCalcScore(calcState.path.length, calcState.minSteps);
        renderCalcGrid();
        updateCalcHud();
        setCalcMessage('一手戻しました。');
      }

      function handleCalcGiveUp() {
        if (calcState.stageClear) {
          setCalcMessage('既にクリアしました。盤面リセットで新しいターゲットに挑みましょう。');
          return;
        }
        if (calcState.gaveUp) {
          setCalcMessage('すでに最短経路を表示中です。盤面をリセットしてください。');
          return;
        }
        calcState.gaveUp = true;
        calcState.shortestPath = findCalcMinPath(calcState.grid, calcState.target);
        if (calcState.shortestPath.length) {
          showCalcAlert(`ギブアップ！最短経路を表示中（手数: ${calcState.shortestPath.length}）`);
          setCalcMessage('淡い赤色のマスが最短経路です。盤面リセットで再挑戦できます。');
        } else {
          showCalcAlert('ギブアップしましたが、目標値への経路は見つかりませんでした。');
          setCalcMessage('盤面をリセットして別の目標に挑みましょう。');
        }
        updateCalcSolutionList();
        renderCalcGrid();
        updateCalcHud();
      }

      calcGridBoard.addEventListener('click', (event) => {
        const button = event.target.closest('button');
        if (!button) return;
        const row = Number(button.dataset.row);
        const col = Number(button.dataset.col);
        if (Number.isNaN(row) || Number.isNaN(col)) return;
        handleCalcCellClick(row, col);
      });

      calcResetBoardButton.addEventListener('click', () => {
        resetCalcGame(true);
      });

      calcResetPathButton.addEventListener('click', () => {
        resetCalcGame(false);
      });

      calcUndoButton.addEventListener('click', undoCalcStep);
      calcGiveUpButton.addEventListener('click', handleCalcGiveUp);
      resetCalcGame(true);

      // Aliquot sequence explorer
      const aliquotForm = document.getElementById('aliquotForm');
      const aliquotInput = document.getElementById('aliquotInput');
      const aliquotRandomButton = document.getElementById('aliquotRandom');
      const aliquotSequenceList = document.getElementById('aliquotSequenceList');
      const aliquotSummaryList = document.getElementById('aliquotSummaryList');
      const aliquotStatus = document.getElementById('aliquotStatus');
      const aliquotOrbit = document.getElementById('aliquotOrbit');
      const aliquotExplanation = document.getElementById('aliquotExplanation');
      const aliquotDivisorsList = document.getElementById('aliquotDivisors');
      const aliquotReplayButton = document.getElementById('aliquotReplay');

      const ALIQUOT_TIMEOUT_MS = 20000;
      const ALIQUOT_TIME_SLICE_MS = 18;
      const ALIQUOT_MAX_STEPS = 1400;
      const ALIQUOT_HISTORY_LIMIT = 10;
      let aliquotAnimationTimer = null;
      let lastAliquotHistory = [];
      let lastAliquotTokens = [];
      let aliquotComputeToken = 0;

      function getProperDivisors(n) {
        if (n <= 1) return [];
        const divisors = [1];
        const limit = Math.floor(Math.sqrt(n));
        for (let i = 2; i <= limit; i += 1) {
          if (n % i === 0) {
            divisors.push(i);
            const pair = n / i;
            if (pair !== i && pair !== n) {
              divisors.push(pair);
            }
          }
        }
        return divisors;
      }

      function classifyAliquot(result) {
        if (result.timedOut) {
          return {
            label: 'タイムアウト',
            description: '20秒以内に振る舞いを判定できませんでした。途中までの数列を表示しています。',
          };
        }
        if (result.loopLength === 1) {
          const value = result.repeatedCycle[0];
          return {
            label: '完全数',
            description: `${value} は真の約数の和が自分自身に一致する完全数です。`,
          };
        }
        if (result.loopLength === 2) {
          return {
            label: '友愛数',
            description: `${result.repeatedCycle[0]} と ${result.repeatedCycle[1]} が互いに真の約数の和になっています。`,
          };
        }
        if (result.loopLength >= 3) {
          return {
            label: '社交数',
            description: `${result.loopLength} 個の数が巡回する社交数の輪を形成しています。`,
          };
        }
        if (!result.loopLength && result.sequence[result.sequence.length - 1] === 0) {
          return {
            label: '収束',
            description: '1 に到達したあと 0 へ落ち着くため、この数列は有限で停止します。',
          };
        }
        return {
          label: '未確定',
          description: '未知の挙動です。別の初項でも試してみましょう。',
        };
      }

      async function buildAliquotSequence(start) {
        const sequence = [start];
        const seen = new Map([[start, 0]]);
        const history = [];
        let current = start;
        let loopStartIndex = null;
        let repeatedCycle = [];
        let timedOut = false;
        const startTime = performance.now();
        let sliceDeadline = performance.now() + ALIQUOT_TIME_SLICE_MS;
        while (current !== 1) {
          const now = performance.now();
          if (now - startTime > ALIQUOT_TIMEOUT_MS || sequence.length > ALIQUOT_MAX_STEPS) {
            timedOut = true;
            break;
          }
          if (now > sliceDeadline) {
            await new Promise((resolve) => requestAnimationFrame(resolve));
            sliceDeadline = performance.now() + ALIQUOT_TIME_SLICE_MS;
          }
          const divisors = getProperDivisors(current);
          const sum = divisors.reduce((acc, val) => acc + val, 0);
          history.push({ value: current, divisors, sum });
          current = sum;
          if (seen.has(current)) {
            loopStartIndex = seen.get(current);
            repeatedCycle = sequence.slice(loopStartIndex);
            sequence.push(current);
            break;
          }
          sequence.push(current);
          seen.set(current, sequence.length - 1);
        }
        if (!timedOut && loopStartIndex === null && current === 1) {
          history.push({ value: 1, divisors: [], sum: 0 });
          sequence.push(0);
        }
        const loopLength = repeatedCycle.length;
        const classification = classifyAliquot({
          timedOut,
          loopLength,
          repeatedCycle,
          sequence,
        });
        return {
          sequence,
          history,
          timedOut,
          loopLength,
          repeatedCycle,
          loopStartIndex,
          classification,
        };
      }

      function buildAliquotTokens(result) {
        const tokens = result.sequence.map((value, index) => {
          const inCycle =
            result.loopStartIndex !== null
              ? index >= result.loopStartIndex && index < result.loopStartIndex + result.loopLength
              : false;
          return { type: 'value', value: String(value), isCycle: inCycle };
        });
        if (result.loopStartIndex !== null) {
          tokens.splice(result.loopStartIndex, 0, { type: 'label', value: 'repeat part →' });
          tokens.push({ type: 'ellipsis', value: '…' });
        } else if (result.timedOut) {
          tokens.push({ type: 'ellipsis', value: '…' });
        }
        return tokens;
      }

      function renderAliquotSequence(tokens) {
        aliquotSequenceList.innerHTML = '';
        if (!tokens.length) {
          const placeholder = document.createElement('li');
          placeholder.className = 'calc-history-empty';
          placeholder.textContent = 'まだ数列を生成していません。';
          aliquotSequenceList.appendChild(placeholder);
          return;
        }
        tokens.forEach((token) => {
          const item = document.createElement('li');
          item.textContent = token.value;
          if (token.type === 'label') {
            item.style.background = 'rgba(255, 255, 255, 0.02)';
            item.style.fontStyle = 'italic';
            item.style.border = '1px dashed rgba(255, 255, 255, 0.2)';
          }
          if (token.type === 'ellipsis') {
            item.style.fontWeight = '700';
          }
          if (token.isCycle) {
            item.dataset.cycle = 'true';
          }
          aliquotSequenceList.appendChild(item);
        });
      }

      function updateAliquotSummary(result) {
        const { classification, loopLength, repeatedCycle, timedOut, sequence } = result;
        aliquotSummaryList.innerHTML = '';
        const summaryItems = [];
        summaryItems.push(`${classification.label}`);
        summaryItems.push(classification.description);
        if (loopLength >= 2) {
          summaryItems.push(`巡回の長さ: ${loopLength}`);
        }
        if (timedOut) {
          summaryItems.push(`ここまでの生成数: ${sequence.length} 項`);
        }
        summaryItems.forEach((text) => {
          const li = document.createElement('li');
          li.textContent = text;
          aliquotSummaryList.appendChild(li);
        });
        aliquotStatus.textContent = classification.description;
      }

      function renderAliquotOrbit(history) {
        aliquotOrbit.innerHTML = '';
        if (!history.length) {
          const placeholder = document.createElement('div');
          placeholder.className = 'aliquot-node';
          placeholder.textContent = '---';
          aliquotOrbit.appendChild(placeholder);
          return;
        }
        const limited = history.slice(0, ALIQUOT_HISTORY_LIMIT);
        const fragment = document.createDocumentFragment();
        limited.forEach((entry, index) => {
          const node = document.createElement('div');
          node.className = 'aliquot-node';
          node.dataset.index = index;
          node.textContent = entry.value;
          fragment.appendChild(node);
        });
        aliquotOrbit.appendChild(fragment);
      }

      function updateDivisorsList(divisors) {
        aliquotDivisorsList.innerHTML = '';
        if (!divisors.length) {
          const li = document.createElement('li');
          li.textContent = '（なし）';
          aliquotDivisorsList.appendChild(li);
          return;
        }
        [...divisors]
          .sort((a, b) => a - b)
          .forEach((value) => {
            const li = document.createElement('li');
            li.textContent = value;
            aliquotDivisorsList.appendChild(li);
          });
      }

      function playAliquotAnimation() {
        if (!lastAliquotHistory.length) return;
        if (aliquotAnimationTimer) {
          clearTimeout(aliquotAnimationTimer);
        }
        aliquotReplayButton.disabled = true;
        const nodes = Array.from(aliquotOrbit.querySelectorAll('.aliquot-node'));
        nodes.forEach((node) => node.classList.remove('aliquot-node--active'));
        let index = 0;
        const limitedHistory = lastAliquotHistory.slice(0, nodes.length);
        const animationStep = () => {
          nodes.forEach((node) => node.classList.remove('aliquot-node--active'));
          const entry = limitedHistory[index];
          if (!entry) {
            aliquotReplayButton.disabled = false;
            aliquotExplanation.textContent = 'アニメーションが完了しました。';
            return;
          }
          const node = nodes[index];
          if (node) {
            node.classList.add('aliquot-node--active');
          }
          const divisorText =
            entry.divisors.length > 0
              ? `${entry.value} の真の約数 ${entry.divisors.length} 個を合計すると ${entry.sum} です。`
              : `${entry.value} には真の約数がないので 0 になります。`;
          aliquotExplanation.textContent = divisorText;
          updateDivisorsList(entry.divisors);
          index += 1;
          if (index >= limitedHistory.length) {
            aliquotReplayButton.disabled = false;
            return;
          }
          aliquotAnimationTimer = setTimeout(animationStep, 1500);
        };
        animationStep();
      }

      function stopAliquotAnimation() {
        if (aliquotAnimationTimer) {
          clearTimeout(aliquotAnimationTimer);
          aliquotAnimationTimer = null;
        }
        aliquotReplayButton.disabled = !lastAliquotHistory.length;
      }

      async function runAliquotComputation(value) {
        const token = ++aliquotComputeToken;
        stopAliquotAnimation();
        aliquotStatus.textContent = '数列を生成中…';
        aliquotSequenceList.innerHTML = '';
        const loadingItem = document.createElement('li');
        loadingItem.className = 'calc-history-empty';
        loadingItem.textContent = '計算中…';
        aliquotSequenceList.appendChild(loadingItem);
        try {
          const result = await buildAliquotSequence(value);
          if (token !== aliquotComputeToken) {
            return;
          }
          const tokens = buildAliquotTokens(result);
          renderAliquotSequence(tokens);
          updateAliquotSummary(result);
          renderAliquotOrbit(result.history);
          lastAliquotHistory = result.history;
          lastAliquotTokens = tokens;
          aliquotReplayButton.disabled = !result.history.length;
          if (result.history.length) {
            aliquotExplanation.textContent = '真の約数の和の流れをアニメーションできます。';
            aliquotDivisorsList.innerHTML = '';
          } else {
            aliquotExplanation.textContent = '真の約数の和をたどると、複雑な軌跡でも必ずどこかへ導かれます。';
            aliquotDivisorsList.innerHTML = '';
          }
        } catch (error) {
          if (token !== aliquotComputeToken) {
            return;
          }
          console.error(error);
          aliquotStatus.textContent = '計算中に問題が発生しました。';
          aliquotSequenceList.innerHTML = '';
          aliquotReplayButton.disabled = true;
        }
      }

      aliquotForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const value = Number(aliquotInput.value);
        if (!Number.isInteger(value) || value < 1) {
          aliquotStatus.textContent = '1以上の自然数を入力してください。';
          return;
        }
        runAliquotComputation(value);
      });

      aliquotRandomButton.addEventListener('click', () => {
        const randomValue = Math.floor(Math.random() * 500) + 2;
        aliquotInput.value = randomValue;
        runAliquotComputation(randomValue);
      });

      aliquotReplayButton.addEventListener('click', playAliquotAnimation);

      runAliquotComputation(Number(aliquotInput.value));

      // initial setup
      initializeFractal();
      resetHanoi();
    </script>
  </body>
</html>
