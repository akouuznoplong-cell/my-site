<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>電脳幾何空間</title>
    <style>
      :root {
        color-scheme: dark;
        --deck: 10deg;
        --neon: #0ff;
        --accent: #f0f;
        --deep: #090b1a;
        --grid: rgba(12, 46, 74, 0.7);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Inter", "游ゴシック体", sans-serif;
        background: radial-gradient(circle at top, rgba(12, 72, 114, 0.45), transparent 40%),
          linear-gradient(180deg, #02050b 0%, #0d0e1a 55%, #03050e 100%);
        color: #f5f5ff;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: linear-gradient(90deg, transparent 45%, rgba(255, 255, 255, 0.04) 50%),
          linear-gradient(180deg, transparent 45%, rgba(255, 255, 255, 0.03) 50%);
        background-size: 120px 120px;
        z-index: -2;
      }
      body::after {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(circle at 20% 20%, rgba(128, 255, 255, 0.08), transparent 40%),
          radial-gradient(circle at 80% 10%, rgba(244, 90, 255, 0.1), transparent 45%);
        z-index: -1;
        filter: blur(30px);
        opacity: 0.8;
      }
      .formula-layer {
        position: fixed;
        inset: 0;
        z-index: -3;
        pointer-events: none;
        background:
          radial-gradient(circle at 60% 35%, rgba(0, 255, 255, 0.04), transparent 45%),
          radial-gradient(circle at 30% 50%, rgba(255, 0, 255, 0.03), transparent 40%),
          conic-gradient(from 60deg at 50% 40%, rgba(255, 255, 255, 0.08), transparent 40%);
        animation: rotateBackground 65s linear infinite;
        overflow: hidden;
      }
      .formula-layer svg {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0.35;
        mix-blend-mode: screen;
        animation: driftFormulas 50s linear infinite;
      }
      .formula-layer svg text {
        fill: rgba(255, 255, 255, 0.55);
        letter-spacing: 0.2em;
        font-family: "Source Code Pro", "Courier New", monospace;
      }
      .formula-layer svg circle,
      .formula-layer svg path {
        filter: drop-shadow(0 0 12px rgba(0, 255, 255, 0.35));
      }
      main {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 2rem;
        padding: 2rem clamp(1rem, 4vw, 4rem) 4rem;
      }
      .panel {
        backdrop-filter: blur(24px);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 24px;
        padding: clamp(1.5rem, 3vw, 2.5rem);
        background: rgba(5, 9, 20, 0.75);
        box-shadow: 0 20px 60px rgba(2, 3, 7, 0.8);
      }
      h1,
      h2,
      h3 {
        font-weight: 600;
        line-height: 1.3;
      }
      .hero {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        position: relative;
        overflow: hidden;
      }
      .hero::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.12), transparent 50%);
        pointer-events: none;
      }
      .hero h1 {
        font-size: clamp(2.4rem, 4vw, 3.4rem);
      }
      .hero p {
        margin: 0;
        color: #cce3ff;
        max-width: 70ch;
      }
      .mode-selector {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      .mode-selector button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 999px;
        padding: 0.65rem 1.4rem;
        background: transparent;
        color: inherit;
        font-weight: 500;
        cursor: pointer;
        transition: border-color 0.2s ease, transform 0.2s ease;
      }
      .mode-selector button:hover {
        border-color: var(--neon);
        transform: translateY(-2px);
      }
      #fractal {
        display: grid;
        grid-template-columns: minmax(0, 360px) 1fr;
        gap: 2rem;
      }
      .fractal-info {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .fractal-grid {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .control-group {
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
        align-items: center;
        font-size: 0.95rem;
      }
      .control-group label {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        color: #9ab4ff;
      }
      .control-group input[type="range"] {
        width: 100%;
      }
      .control-row {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      canvas {
        width: 100%;
        height: 420px;
        border-radius: 18px;
        background: rgba(3, 6, 15, 0.85);
        box-shadow: inset 0 0 40px rgba(0, 255, 255, 0.08);
      }
      button.primary {
        align-self: flex-start;
        padding: 0.85rem 1.6rem;
        border-radius: 999px;
        border: none;
        background: linear-gradient(120deg, rgba(0, 255, 255, 0.25), rgba(255, 255, 255, 0.1));
        color: #f3ffff;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      }
      #constants {
        position: relative;
        overflow: hidden;
      }
      #constants::after {
        content: "";
        position: absolute;
        inset: 10% 0;
        background: repeating-linear-gradient(90deg, transparent 0 20px, rgba(255, 255, 255, 0.04) 21px 40px);
        opacity: 0.4;
      }
      .constant-history {
        font-size: 0.95rem;
        color: #9dbaff;
        margin: 0;
        line-height: 1.5;
      }
      .constant-digits {
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 1rem;
        letter-spacing: 0.18em;
        color: #cce8ff;
        background: rgba(4, 10, 28, 0.9);
        border-radius: 14px;
        padding: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.08);
        min-height: 210px;
        max-height: 240px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-break: break-all;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.45);
      }
      .constants-display {
        position: relative;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
      }
      .constant-card {
        border-radius: 18px;
        padding: 1.2rem;
        background: rgba(2, 11, 32, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 10px 30px rgba(2, 4, 10, 0.8);
        min-height: 200px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
      .constant-card h3 {
        margin: 0;
        font-size: 1.2rem;
      }
      .constant-card p {
        margin: 0.8rem 0 0;
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 0.95rem;
        line-height: 1.5;
        white-space: pre-wrap;
        letter-spacing: 0.05em;
        color: #cce8ff;
      }
      #hanoi {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
      .hanoi-body {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
      }
      .tower-group {
        display: flex;
        flex: 1;
        justify-content: space-between;
        gap: 1rem;
      }
      .tower-column {
        flex: 1;
        min-width: 160px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        position: relative;
      }
      .tower-name {
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.2em;
        color: rgba(255, 255, 255, 0.7);
      }
      .tower {
        width: 100%;
        height: 210px;
        border-radius: 14px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(12, 18, 46, 0.8));
        border: 1px solid rgba(255, 255, 255, 0.08);
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        align-items: center;
        padding-bottom: 10px;
        box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.6);
        cursor: grab;
        transition: border-color 0.25s ease, box-shadow 0.25s ease, transform 0.25s ease;
      }
      .tower::after {
        content: "";
        position: absolute;
        width: 4px;
        height: 90%;
        background: rgba(255, 255, 255, 0.15);
        bottom: 10px;
        left: calc(50% - 2px);
        border-radius: 2px;
      }
      .tower:active {
        cursor: grabbing;
      }
      .tower-drag-source {
        border-color: var(--neon);
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.4), inset 0 0 35px rgba(255, 255, 255, 0.1);
      }
      .tower-drag-target {
        border-color: var(--accent);
        box-shadow: 0 0 30px rgba(244, 90, 255, 0.35), inset 0 0 28px rgba(255, 255, 255, 0.08);
      }
      .disk {
        height: 18px;
        border-radius: 12px 12px 4px 4px;
        margin-bottom: 6px;
        transition: transform 0.3s ease;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
        position: relative;
      }
      .disk::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .tower-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
      }
      .tower-controls label {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        color: #b7c5ff;
      }
      .tower-controls select,
      .tower-controls input[type="range"] {
        appearance: none;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 0.5rem 0.75rem;
        color: inherit;
      }
      .hanoi-actions {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }
      .hanoi-actions button {
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 999px;
        padding: 0.65rem 1.2rem;
        background: transparent;
        color: #f3ffff;
        font-weight: 500;
        cursor: pointer;
      }
      .hanoi-actions button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .message {
        min-height: 1.4rem;
        font-size: 0.9rem;
        color: #9ab4ff;
      }
      #circleGame {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .circle-game {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        align-items: flex-start;
        justify-content: space-between;
      }
      .circle-board {
        --board-size: 9;
        position: relative;
        min-width: 320px;
        width: min(520px, 100%);
        aspect-ratio: 1 / 1;
        border-radius: 18px;
        padding: 1rem;
        background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.08), transparent 60%),
          linear-gradient(90deg, rgba(255, 255, 255, 0.08) 1px, transparent 1px),
          linear-gradient(rgba(255, 255, 255, 0.08) 1px, transparent 1px);
        background-size: calc(100% / (var(--board-size) - 1)) calc(100% / (var(--board-size) - 1));
        display: grid;
        grid-template-columns: repeat(var(--board-size), 1fr);
        grid-template-rows: repeat(var(--board-size), 1fr);
        gap: 0;
        box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.7), 0 30px 50px rgba(5, 8, 25, 0.7);
      }
      .circle-cell {
        border: none;
        background: transparent;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        transition: transform 0.15s ease, opacity 0.2s ease;
      }
      .circle-cell::after {
        content: "";
        position: absolute;
        inset: 50%;
        transform: translate(-50%, -50%);
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.12);
        pointer-events: none;
      }
      .circle-cell .stone {
        width: 58%;
        height: 58%;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.4);
        box-shadow: 0 0 12px rgba(0, 255, 255, 0.35);
        transition: background 0.25s ease, box-shadow 0.25s ease;
      }
      .circle-cell[data-player="0"] .stone {
        opacity: 0;
        box-shadow: none;
      }
      .circle-cell[data-player="1"] .stone {
        background: radial-gradient(circle, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.6));
      }
      .circle-cell[data-player="2"] .stone {
        background: radial-gradient(circle, rgba(244, 90, 255, 0.85), rgba(244, 90, 255, 0.4));
      }
      .circle-cell.circle-cell--last {
        transform: scale(1.05);
      }
      .circle-game-info {
        flex: 1;
        min-width: 240px;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .circle-scoreboard {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.75rem;
      }
      .circle-scoreboard div {
        padding: 0.9rem;
        border-radius: 14px;
        background: rgba(10, 26, 50, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.4);
      }
      .circle-scoreboard strong {
        display: block;
        font-size: 0.85rem;
        letter-spacing: 0.2em;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 0.35rem;
      }
      .circle-scoreboard--wide {
        grid-column: 1 / -1;
      }
      .circle-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      .circle-controls label,
      .circle-controls button {
        font-size: 0.9rem;
      }
      .circle-controls select,
      .circle-controls button {
        appearance: none;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.05);
        color: inherit;
        padding: 0.5rem 0.9rem;
      }
      .circle-controls button {
        cursor: pointer;
      }
      .circle-message {
        min-height: 2rem;
        font-size: 0.95rem;
        color: #cbe8ff;
      }
      .circle-ai-info {
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.7);
        margin: 0;
      }
      @keyframes driftFormulas {
        0% {
          transform: translate(0%, 0%);
        }
        100% {
          transform: translate(-15%, -10%);
        }
      }
      @keyframes rotateBackground {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      @media (max-width: 900px) {
        #fractal {
          grid-template-columns: 1fr;
        }
      }
      @media (max-width: 600px) {
        .tower-group {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="formula-layer" aria-hidden="true">
      <svg viewBox="0 0 720 240" preserveAspectRatio="xMidYMid slice">
        <text x="20" y="50" font-size="32">∑_{n=1}^∞ 1/n^2 = π^2/6</text>
        <text x="20" y="100" font-size="32">e^{iπ} + 1 = 0</text>
        <text x="20" y="150" font-size="26">ζ(s) = ∑_{n=1}^∞ 1/n^s</text>
        <text x="20" y="200" font-size="26">f(z)=z^2+c ... フラクタル軌跡</text>
        <circle cx="540" cy="120" r="60" stroke-width="1.5" stroke="rgba(255,255,255,0.25)" fill="none" />
        <circle cx="600" cy="60" r="32" stroke-width="0.6" stroke="rgba(0,255,255,0.4)" fill="none" />
        <path d="M420 40 Q 470 20 520 60" stroke="rgba(255,255,255,0.4)" stroke-width="1" fill="none" />
      </svg>
    </div>
    <main>
      <section class="panel hero">
        <p class="eyebrow">知の探求</p>
        <h1>幾何学的な装飾と知的な遊び</h1>
        <p>
          こちらは線と光の言語で構成されたミステリアスなインターフェース。幾何学パターンの
         調整、定数の美しい浮遊、そして証明にも使われるハノイの塔まで、一つの流れにまとめました。
        </p>
        <div class="mode-selector">
          <button class="mode-button" data-target="fractal">フラクタルモード</button>
          <button class="mode-button" data-target="constants">定数表示</button>
          <button class="mode-button" data-target="hanoi">ハノイの塔</button>
        </div>
      </section>

      <section id="fractal" class="panel">
        <div class="fractal-info">
          <div>
            <h2>フラクタルで幾何学模様を自在に描く</h2>
            <p>
              分岐の角度や再帰の深さ、縮尺を操作しながら、空間に枝を伸ばしていく。選んだ色が
              ネオンのように幽玄な枝を染め上げます。
            </p>
          </div>
          <div class="fractal-grid">
            <div class="control-row">
              <label>
                フラクタルタイプ
                <select id="fractalType">
                  <option value="tree">枝分かれの森</option>
                  <option value="triangle">シェルピンスキーの三角形</option>
                  <option value="spiral">渦巻く黄金スパイラル</option>
                </select>
              </label>
              <label>
                線の色
                <input type="color" id="branchColor" value="#00ffff" />
              </label>
            </div>
            <div class="control-row">
              <label>
                深さ <span id="depthValue">6</span>
                <input type="range" id="depthRange" min="3" max="8" value="6" />
              </label>
              <label>
                角度 <span id="angleValue">30°</span>
                <input type="range" id="angleRange" min="15" max="60" value="30" />
              </label>
            </div>
            <div class="control-row">
              <label>
                縮尺 <span id="scaleValue">70%</span>
                <input type="range" id="scaleRange" min="50" max="85" value="70" />
              </label>
              <label>
                枝の数 <span id="branchCountValue">3</span>
                <input type="range" id="branchFactorRange" min="2" max="5" value="3" />
              </label>
            </div>
          </div>
        </div>
        <canvas id="fractalCanvas" width="800" height="600"></canvas>
      </section>

      <section id="constants" class="panel">
        <h2>円周率とネイピア数の電脳詩</h2>
        <p>
          背景に浮かぶグリッドを透かして、π と e の数列がサイバーな光の帯となって流れてゆく。
          思考の奥にある普遍性を見つめてください。
        </p>
        <div class="constants-display">
          <article class="constant-card">
            <h3>π (Pi)</h3>
            <p class="constant-history">
              紀元前2000年ごろ、バビロニアとエジプトの数学者たちが円の周りを測り、古代の近似値を発見しました。
              アルキメデスは正多角形で内接・外接してπの上下限を導き、無限の理想へと探査を広げました。
            </p>
            <p class="constant-history">
              以降も文化を超えてπは天文学や物理学に浸透し、計算の歴史は桁数を追い求める旅へと続きます。
            </p>
            <pre class="constant-digits" id="piDigits" aria-label="円周率の桁"></pre>
          </article>
          <article class="constant-card">
            <h3>e (ネイピア数)</h3>
            <p class="constant-history">
              ジョン・ネイピア（1550-1617）は自然対数の概念とともに、この成長率の定数を提示しました。
              その後、解析学者たちは微分積分や連続複利の裏側にeを見出し、数学の軸に据えました。
            </p>
            <p class="constant-history">
              現代ではオイラーの公式や無限級数として鮮烈な姿を見せ、虚数単位と美しく結びついています。
            </p>
            <pre class="constant-digits" id="eDigits" aria-label="ネイピア数の桁"></pre>
          </article>
        </div>
      </section>

      <section id="hanoi" class="panel">
        <h2>ハノイの塔で論理を遊ぶ</h2>
        <p>
          解くには注意深い論理が必要。ディスクの枚数を変えて適応し、塔を移し替える感覚を直感的に確かめましょう。
        </p>
        <div class="hanoi-body">
          <div class="tower-group">
            <div class="tower-column">
              <span class="tower-name">塔 A</span>
              <div class="tower" data-index="0"></div>
            </div>
            <div class="tower-column">
              <span class="tower-name">塔 B</span>
              <div class="tower" data-index="1"></div>
            </div>
            <div class="tower-column">
              <span class="tower-name">塔 C</span>
              <div class="tower" data-index="2"></div>
            </div>
          </div>
          <div class="tower-controls">
            <label>
              ディスク数 <span id="diskCountValue">5</span>
              <input type="range" id="diskCount" min="3" max="7" value="5" />
            </label>
            <label>
              開始塔
              <select id="fromTower">
                <option value="0">A</option>
                <option value="1">B</option>
                <option value="2">C</option>
              </select>
            </label>
            <label>
              移動先
              <select id="toTower">
                <option value="0">A</option>
                <option value="1">B</option>
                <option value="2">C</option>
              </select>
            </label>
          </div>
          <div class="hanoi-actions">
            <button id="moveDisk">手動移動</button>
            <button id="autoSolve">自動で解く</button>
            <button id="resetHanoi">初期状態に戻す</button>
          </div>
      <p class="message" id="hanoiMessage">自由な手でディスクを移してください。</p>
        </div>
      </section>

      <section id="circleGame" class="panel">
        <h2>円を避ける碁盤の学習対戦</h2>
        <p>
          囲碁の交差点を舞台に、先攻と後攻が交互に石を置いてゆきます。既存の3点が描く円の円周上に
          4点目を置くと失敗。AIは対戦の結果を蓄積しながら、ユーザーの選択を学習していきます。
        </p>
        <div class="circle-game">
          <div id="circleBoard" class="circle-board" role="grid" aria-label="円を避けるゲームの碁盤"></div>
          <div class="circle-game-info">
            <div class="circle-scoreboard">
              <div>
                <strong>あなた</strong>
                <span id="circleHumanScore">0 勝</span>
              </div>
              <div>
                <strong>AI</strong>
                <span id="circleAiScore">0 勝</span>
              </div>
              <div class="circle-scoreboard--wide">
                <strong>引き分け</strong>
                <span id="circleDraws">0 回</span>
              </div>
            </div>
            <div class="circle-controls">
              <label>
                先攻
                <select id="circleFirstPlayer">
                  <option value="human">あなた</option>
                  <option value="ai">AI</option>
                </select>
              </label>
              <button type="button" id="circleReset">盤面をリセット</button>
            </div>
            <p class="circle-message" id="circleMessage">
              線上に4点をつくらないように気をつけながら石を置いてください。
            </p>
            <p class="circle-ai-info" id="circleAiInfo">
              AIは対戦データを蓄積中。初期の探索ではランダムに打つこともあります。
            </p>
          </div>
        </div>
      </section>
    </main>

    <script>
      // Hero mode buttons scroll to sections
      document.querySelectorAll('.mode-button').forEach((button) => {
        button.addEventListener('click', () => {
          const targetId = button.getAttribute('data-target');
          document.getElementById(targetId).scrollIntoView({ behavior: 'smooth' });
        });
      });

      const depthRange = document.getElementById('depthRange');
      const angleRange = document.getElementById('angleRange');
      const scaleRange = document.getElementById('scaleRange');
      const branchFactorRange = document.getElementById('branchFactorRange');
      const depthValue = document.getElementById('depthValue');
      const angleValue = document.getElementById('angleValue');
      const scaleValue = document.getElementById('scaleValue');
      const branchCountValue = document.getElementById('branchCountValue');
      const branchColor = document.getElementById('branchColor');
      const fractalTypeSelect = document.getElementById('fractalType');
      const fractalCanvas = document.getElementById('fractalCanvas');
      const ctx = fractalCanvas.getContext('2d');

      const piDigits =
        '3.14159265358979323846264338327950288419716939937510'
        + '58209749445923078164062862089986280348253421170679';
      const eDigits =
        '2.71828182845904523536028747135266249775724709369995'
        + '95749669676277240766303535475945713821785251664274';
      const piDisplay = document.getElementById('piDigits');
      const eDisplay = document.getElementById('eDigits');

      function formatConstantDigits(str) {
        const groupSize = 60;
        const groups = [];
        for (let i = 0; i < str.length; i += groupSize) {
          groups.push(str.slice(i, i + groupSize));
        }
        return groups.join('\n');
      }

      function updateControlLabels() {
        depthValue.textContent = depthRange.value;
        angleValue.textContent = `${angleRange.value}°`;
        scaleValue.textContent = `${scaleRange.value}%`;
        branchCountValue.textContent = branchFactorRange.value;
      }

      function resizeCanvas() {
        const rect = fractalCanvas.getBoundingClientRect();
        fractalCanvas.width = rect.width;
        fractalCanvas.height = rect.height;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }

      function drawBranch(ctx, x, y, length, angle, depth, opts) {
        if (depth === 0 || length < 2) return;
        const x2 = x + Math.cos(angle) * length;
        const y2 = y + Math.sin(angle) * length;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x2, y2);
        ctx.lineWidth = Math.max(1, depth * 1.4);
        ctx.strokeStyle = opts.color;
        ctx.stroke();
        const nextLength = length * (opts.scale * 0.92);
        const children = Math.max(2, opts.branchFactor);
        const baseSpread = opts.branchSpread;
        for (let i = 0; i < children; i += 1) {
          const offset = children === 1 ? 0 : (i / (children - 1) - 0.5);
          const jitter = Math.sin(depth * 0.45 + i) * 0.07;
          const subAngle = angle + offset * baseSpread + offset * jitter;
          drawBranch(ctx, x2, y2, nextLength, subAngle, depth - 1, opts);
        }
      }

      function drawBinaryTree(ctx, opts) {
        ctx.save();
        ctx.translate(opts.width / 2, opts.height * 0.9);
        drawBranch(ctx, 0, 0, opts.height * 0.25 * opts.scale, -Math.PI / 2, opts.depth, opts);
        ctx.restore();
      }

      function midpoint(p1, p2) {
        return {
          x: (p1.x + p2.x) / 2,
          y: (p1.y + p2.y) / 2,
        };
      }

      function rotatePoint(x, y, cx, cy, angle) {
        const dx = x - cx;
        const dy = y - cy;
        return {
          x: cx + dx * Math.cos(angle) - dy * Math.sin(angle),
          y: cy + dx * Math.sin(angle) + dy * Math.cos(angle),
        };
      }

      function drawSierpinskiTriangle(ctx, points, depth) {
        if (depth === 0) {
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          ctx.lineTo(points[1].x, points[1].y);
          ctx.lineTo(points[2].x, points[2].y);
          ctx.closePath();
          ctx.fill();
          return;
        }
        const [a, b, c] = points;
        const ab = midpoint(a, b);
        const bc = midpoint(b, c);
        const ac = midpoint(a, c);
        drawSierpinskiTriangle(ctx, [a, ab, ac], depth - 1);
        drawSierpinskiTriangle(ctx, [ab, b, bc], depth - 1);
        drawSierpinskiTriangle(ctx, [ac, bc, c], depth - 1);
      }

      function drawSierpinski(ctx, opts) {
        const { width, height, depth, color, scale, bias } = opts;
        const centerX = width / 2;
        const centerY = height * 0.55;
        const radius = Math.min(width, height) * (0.25 + scale * 0.22);
        const points = [
          { x: centerX, y: centerY - radius },
          { x: centerX - radius, y: centerY + radius },
          { x: centerX + radius, y: centerY + radius },
        ].map((point) => rotatePoint(point.x, point.y, centerX, centerY, bias * 0.65));
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.5;
        drawSierpinskiTriangle(ctx, points, Math.min(depth, 8));
        ctx.globalAlpha = 1;
      }

      function drawSpiral(ctx, opts) {
        const { width, height, depth, scale, color, sliderAngle, branchFactor } = opts;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.2;
        const previousShadowBlur = ctx.shadowBlur;
        const previousShadowColor = ctx.shadowColor;
        ctx.shadowBlur = 16;
        ctx.shadowColor = color;
        let x = width / 2;
        let y = height / 2;
        let length = Math.min(width, height) * (0.25 + scale * 0.3);
        let currentAngle = sliderAngle;
        const steps = depth * 10 + branchFactor * 4;
        for (let step = 0; step < steps && length > 3; step += 1) {
          const nextX = x + Math.cos(currentAngle) * length;
          const nextY = y + Math.sin(currentAngle) * length;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(nextX, nextY);
          ctx.stroke();
          x = nextX;
          y = nextY;
          length *= 0.92;
          currentAngle += (Math.PI / (22 + step)) + (branchFactor * 0.02) + Math.sin(step * 0.2) * 0.04;
        }
        ctx.shadowBlur = previousShadowBlur;
        ctx.shadowColor = previousShadowColor;
      }

      const fractalDrawers = {
        tree: drawBinaryTree,
        triangle: drawSierpinski,
        spiral: drawSpiral,
      };

      function renderFractal() {
        const width = fractalCanvas.width;
        const height = fractalCanvas.height;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = 'rgba(1, 2, 5, 0.65)';
        ctx.fillRect(0, 0, width, height);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        const scaleFactor = Math.max(0.2, parseFloat(scaleRange.value) / 100);
        const branchFactor = parseInt(branchFactorRange.value, 10);
        const branchSpread = Math.PI * (0.35 + branchFactor * 0.08);
        const sliderAngle = (parseInt(angleRange.value, 10) * Math.PI) / 180;
        const depthValueInput = parseInt(depthRange.value, 10);
        const fractalType = fractalTypeSelect.value;
        const options = {
          width,
          height,
          depth: fractalType === 'triangle' ? Math.min(depthValueInput, 7) : depthValueInput,
          scale: scaleFactor,
          color: branchColor.value,
          sliderAngle,
          branchFactor,
          branchSpread,
          bias: Math.cos(branchFactor * 0.35),
        };
        fractalDrawers[fractalType](ctx, options);
      }

      function initializeFractal() {
        updateControlLabels();
        resizeCanvas();
        renderFractal();
      }

      const controlElements = [
        depthRange,
        angleRange,
        scaleRange,
        branchFactorRange,
        fractalTypeSelect,
      ];

      controlElements.forEach((element) => {
        element.addEventListener('input', () => {
          updateControlLabels();
          renderFractal();
        });
      });

      branchColor.addEventListener('input', renderFractal);

      window.addEventListener('resize', () => {
        resizeCanvas();
        renderFractal();
      });

      piDisplay.textContent = formatConstantDigits(piDigits);
      eDisplay.textContent = formatConstantDigits(eDigits);
      initializeFractal();

      // Hanoi towers
      const diskCountInput = document.getElementById('diskCount');
      const diskCountValue = document.getElementById('diskCountValue');
      const fromSelect = document.getElementById('fromTower');
      const toSelect = document.getElementById('toTower');
      const moveButton = document.getElementById('moveDisk');
      const autoSolveButton = document.getElementById('autoSolve');
      const resetButton = document.getElementById('resetHanoi');
      const messageEl = document.getElementById('hanoiMessage');
      const towerEls = document.querySelectorAll('.tower');
      let towers = [[], [], []];
      let diskCount = parseInt(diskCountInput.value, 10);
      let autoTimer;
      let dragOrigin = null;

      function createDisks(count) {
        const stack = [];
        for (let i = count; i >= 1; i -= 1) {
          stack.push(i);
        }
        return stack;
      }

      function renderHanoi() {
        towerEls.forEach((towerEl) => {
          const idx = Number(towerEl.dataset.index);
        towerEl.innerHTML = '';
          const stack = towers[idx] || [];
          const ordered = [...stack].sort((a, b) => b - a);
          ordered.forEach((diskSize) => {
            const disk = document.createElement('div');
            disk.className = 'disk';
            const widthRatio = (diskSize / diskCount) * 0.7 + 0.3;
            disk.style.width = `${widthRatio * 100}%`;
            disk.style.background = `linear-gradient(90deg, rgba(0,255,255,0.4), rgba(255,0,255,0.4))`;
            disk.style.order = diskSize;
            towerEl.appendChild(disk);
          });
        });
      }

      function setMessage(text) {
        messageEl.textContent = text;
      }

      function resetHanoi() {
        clearDragHighlight();
        if (autoTimer) {
          clearInterval(autoTimer);
          autoTimer = null;
        }
        diskCount = parseInt(diskCountInput.value, 10);
        diskCountValue.textContent = diskCount;
        towers = [createDisks(diskCount), [], []];
        renderHanoi();
        setMessage(`ディスク数 ${diskCount} で初期化されました。`);
      }

      function moveDisk(from, to, silent = false) {
        if (from === to) {
          if (!silent) setMessage('異なる塔を選んでください。');
          return false;
        }
        const source = towers[from];
        const target = towers[to];
        if (source.length === 0) {
          if (!silent) setMessage('開始塔にディスクがありません。');
          return false;
        }
        const disk = source[source.length - 1];
        const targetTop = target[target.length - 1];
        if (targetTop && disk > targetTop) {
          if (!silent) setMessage('大きなディスクを小さなディスクの上に置けません。');
          return false;
        }
        target.push(source.pop());
        renderHanoi();
        if (!silent) setMessage(`塔 ${String.fromCharCode(65 + from)} -> ${String.fromCharCode(65 + to)} に移動しました。`);
        return true;
      }

      function solveHanoi(n, from, to, aux, moves) {
        if (n === 0) return;
        solveHanoi(n - 1, from, aux, to, moves);
        moves.push([from, to]);
        solveHanoi(n - 1, aux, to, from, moves);
      }

      diskCountInput.addEventListener('input', () => {
        diskCountValue.textContent = diskCountInput.value;
      });

      function clearDragHighlight() {
        dragOrigin = null;
        towerEls.forEach((el) => {
          el.classList.remove('tower-drag-source', 'tower-drag-target');
        });
      }

      towerEls.forEach((towerEl) => {
        towerEl.addEventListener('pointerdown', (event) => {
          event.preventDefault();
          const idx = Number(towerEl.dataset.index);
          if (towers[idx].length === 0) {
            setMessage('この塔にディスクがありません。');
            return;
          }
          dragOrigin = idx;
          towerEl.classList.add('tower-drag-source');
          setMessage(`塔 ${String.fromCharCode(65 + idx)} からドラッグを開始しました。`);
        });
        towerEl.addEventListener('pointerenter', () => {
          if (dragOrigin === null) return;
          const idx = Number(towerEl.dataset.index);
          if (idx !== dragOrigin) {
            towerEl.classList.add('tower-drag-target');
          }
        });
        towerEl.addEventListener('pointerleave', () => {
          towerEl.classList.remove('tower-drag-target');
        });
        towerEl.addEventListener('pointerup', () => {
          if (dragOrigin === null) return;
          const target = Number(towerEl.dataset.index);
          if (target !== dragOrigin) {
            moveDisk(dragOrigin, target);
          } else {
            setMessage('同じ塔には戻せません。');
          }
          clearDragHighlight();
        });
      });

      document.addEventListener('pointerup', (event) => {
        if (dragOrigin === null) return;
        if (!event.target.closest('.tower')) {
          clearDragHighlight();
          setMessage('ドラッグをキャンセルしました。');
        }
      });

      moveButton.addEventListener('click', () => {
        const from = Number(fromSelect.value);
        const to = Number(toSelect.value);
        moveDisk(from, to);
      });

      autoSolveButton.addEventListener('click', () => {
        if (autoTimer) {
          clearInterval(autoTimer);
        }
        const moves = [];
        solveHanoi(diskCount, 0, 2, 1, moves);
        let index = 0;
        autoSolveButton.disabled = true;
        setMessage('自動解答を開始します。');
        autoTimer = setInterval(() => {
          if (index >= moves.length) {
            clearInterval(autoTimer);
            autoTimer = null;
            autoSolveButton.disabled = false;
            setMessage('自動解答が完了しました。');
            return;
          }
          const [from, to] = moves[index];
          moveDisk(from, to, true);
          index += 1;
        }, 420);
      });

      resetButton.addEventListener('click', () => {
        resetHanoi();
      });

      // Circle avoidance game
      const circleBoard = document.getElementById('circleBoard');
      const circleMessage = document.getElementById('circleMessage');
      const circleAiInfo = document.getElementById('circleAiInfo');
      const circleHumanScoreEl = document.getElementById('circleHumanScore');
      const circleAiScoreEl = document.getElementById('circleAiScore');
      const circleDrawsEl = document.getElementById('circleDraws');
      const circleFirstPlayer = document.getElementById('circleFirstPlayer');
      const circleResetButton = document.getElementById('circleReset');
      const circleBoardSize = 9;
      const circleCells = [];
      let circleBoardState = [];
      let circleCurrentPlayer = 1;
      let circleGameOver = false;
      let circleLastMove = null;
      let circleAiTimer = null;
      let circleHumanWins = 0;
      let circleAiWins = 0;
      let circleDrawGames = 0;
      let circleAiMoves = [];
      const circleExperience = loadCircleExperience();

      function loadCircleExperience() {
        try {
          const stored = localStorage.getItem('circleAvoidAI');
          return stored ? JSON.parse(stored) : {};
        } catch (error) {
          return {};
        }
      }

      function saveCircleExperience() {
        try {
          localStorage.setItem('circleAvoidAI', JSON.stringify(circleExperience));
        } catch (error) {
          // ignore storage failures
        }
      }

      function updateAiStatsDisplay() {
        const entries = Object.values(circleExperience);
        const total = entries.reduce((sum, entry) => sum + entry.total, 0);
        const wins = entries.reduce((sum, entry) => sum + entry.wins, 0);
        const rate = total ? Math.round((wins / total) * 100) : 0;
        circleAiInfo.textContent = `学習エントリ ${entries.length} 件 / 勝率 ${rate}% / 訓練 ${total} 回`;
      }

      function buildCircleCells() {
        circleCells.length = 0;
        circleBoard.innerHTML = '';
        for (let row = 0; row < circleBoardSize; row += 1) {
          const rowCells = [];
          for (let col = 0; col < circleBoardSize; col += 1) {
            const cell = document.createElement('button');
            cell.type = 'button';
            cell.className = 'circle-cell';
            cell.dataset.row = row;
            cell.dataset.col = col;
            cell.dataset.player = '0';
            const stone = document.createElement('span');
            stone.className = 'stone';
            cell.appendChild(stone);
            cell.addEventListener('click', () => handleCircleClick(row, col));
            circleBoard.appendChild(cell);
            rowCells.push(cell);
          }
          circleCells.push(rowCells);
        }
      }

      function resetCircleGame() {
        if (circleAiTimer) {
          clearTimeout(circleAiTimer);
          circleAiTimer = null;
        }
        circleAiMoves = [];
        circleGameOver = false;
        circleBoardState = Array.from({ length: circleBoardSize }, () =>
          Array.from({ length: circleBoardSize }, () => 0)
        );
        circleLastMove = null;
        circleCurrentPlayer = circleFirstPlayer.value === 'ai' ? 2 : 1;
        renderCircleBoard();
        circleMessage.textContent =
          circleCurrentPlayer === 2
            ? 'AIが先手で形を探ります…'
            : 'あなたから打ち始めます。';
        if (circleCurrentPlayer === 2) {
          scheduleAiTurn();
        }
      }

      function updateScoreboard() {
        circleHumanScoreEl.textContent = `${circleHumanWins} 勝`;
        circleAiScoreEl.textContent = `${circleAiWins} 勝`;
        circleDrawsEl.textContent = `${circleDrawGames} 回`;
      }

      function renderCircleBoard() {
        circleBoardState.forEach((row, rowIndex) => {
          row.forEach((value, colIndex) => {
            const cell = circleCells[rowIndex][colIndex];
            cell.dataset.player = String(value);
            const isLast =
              circleLastMove &&
              circleLastMove.row === rowIndex &&
              circleLastMove.col === colIndex;
            cell.classList.toggle('circle-cell--last', Boolean(isLast));
          });
        });
      }

      function isBoardFull() {
        return circleBoardState.every((row) => row.every((cell) => cell !== 0));
      }

      function getBoardKey() {
        return circleBoardState.map((row) => row.join('')).join('|');
      }

      function chooseAiMove(stateKey) {
        const empties = [];
        for (let row = 0; row < circleBoardSize; row += 1) {
          for (let col = 0; col < circleBoardSize; col += 1) {
            if (circleBoardState[row][col] === 0) {
              const move = { row, col };
              const loses = checkCircleLoss(row, col);
              empties.push({ ...move, loses });
            }
          }
        }
        if (empties.length === 0) return null;
        const safeMoves = empties.filter((option) => !option.loses);
        const candidates = safeMoves.length ? safeMoves : empties;
        if (Math.random() < 0.2) {
          const pick = candidates[Math.floor(Math.random() * candidates.length)];
          return { row: pick.row, col: pick.col, moveKey: `${stateKey}|${pick.row},${pick.col}` };
        }
        let best = null;
        let bestScore = -Infinity;
        const centerCoord = (circleBoardSize - 1) / 2;
        candidates.forEach((move) => {
          const moveKey = `${stateKey}|${move.row},${move.col}`;
          const record = circleExperience[moveKey];
          const baseRate = record && record.total ? record.wins / record.total : 0.33;
          const novelty = 1 - Math.min(1, (record?.total ?? 0) / 10);
          const distanceScore =
            -Math.hypot(move.row - centerCoord, move.col - centerCoord) * 0.035;
          const score = baseRate + novelty * 0.18 + distanceScore;
          if (score > bestScore) {
            bestScore = score;
            best = { row: move.row, col: move.col, moveKey };
          }
        });
        if (!best) {
          const fallback = candidates[Math.floor(Math.random() * candidates.length)];
          return { row: fallback.row, col: fallback.col, moveKey: `${stateKey}|${fallback.row},${fallback.col}` };
        }
        return best;
      }

      function scheduleAiTurn() {
        if (circleGameOver) return;
        if (circleAiTimer) {
          clearTimeout(circleAiTimer);
          circleAiTimer = null;
        }
        circleMessage.textContent = 'AIが読みを進めています…';
        circleAiTimer = setTimeout(() => {
          circleAiTimer = null;
          if (circleGameOver) return;
          const stateKey = getBoardKey();
          const move = chooseAiMove(stateKey);
          if (!move) {
            finalizeCircleGame('draw', 'これ以上打てる場所がありません。');
            return;
          }
          circleAiMoves.push(move.moveKey);
          makeCircleMove(move.row, move.col, 2);
        }, 560);
      }

      function finalizeCircleGame(outcome, message) {
        circleGameOver = true;
        if (circleAiTimer) {
          clearTimeout(circleAiTimer);
          circleAiTimer = null;
        }
        if (outcome === 'human') {
          circleHumanWins += 1;
        } else if (outcome === 'ai') {
          circleAiWins += 1;
        } else {
          circleDrawGames += 1;
        }
        updateScoreboard();
        circleMessage.textContent = message;
        learnFromExperience(outcome === 'ai');
      }

      function learnFromExperience(aiWon) {
        if (!circleAiMoves.length) {
          updateAiStatsDisplay();
          return;
        }
        circleAiMoves.forEach((moveKey) => {
          const record = circleExperience[moveKey] || { wins: 0, total: 0 };
          record.total += 1;
          if (aiWon) {
            record.wins += 1;
          }
          circleExperience[moveKey] = record;
        });
        circleAiMoves = [];
        saveCircleExperience();
        updateAiStatsDisplay();
      }

      function makeCircleMove(row, col, player) {
        const loses = checkCircleLoss(row, col);
        circleBoardState[row][col] = player;
        circleLastMove = { row, col };
        renderCircleBoard();
        if (loses) {
          const winner = player === 1 ? 'ai' : 'human';
          const reason =
            player === 1
              ? 'あなたは円の円周上に4点を作ってしまいました。'
              : 'AIが円上に4点を置いてしまいました。';
          finalizeCircleGame(winner, reason);
          return;
        }
        if (isBoardFull()) {
          finalizeCircleGame('draw', '盤面がすべて埋まりました。');
          return;
        }
        circleCurrentPlayer = player === 1 ? 2 : 1;
        circleMessage.textContent =
          circleCurrentPlayer === 2
            ? 'AIの番です。'
            : 'あなたの番です。円上の4点を避けてください。';
        if (circleCurrentPlayer === 2) {
          scheduleAiTurn();
        }
      }

      function handleCircleClick(row, col) {
        if (circleGameOver || circleCurrentPlayer !== 1) {
          return;
        }
        if (circleBoardState[row][col] !== 0) {
          circleMessage.textContent = 'そこにはすでに石があります。';
          return;
        }
        makeCircleMove(row, col, 1);
      }

      function checkCircleLoss(row, col) {
        const existingStones = [];
        for (let r = 0; r < circleBoardSize; r += 1) {
          for (let c = 0; c < circleBoardSize; c += 1) {
            if (circleBoardState[r][c]) {
              existingStones.push({ x: c, y: r });
            }
          }
        }
        if (existingStones.length < 3) return false;
        const newPoint = { x: col, y: row };
        const tolerance = 0.04;
        for (let i = 0; i < existingStones.length - 2; i += 1) {
          for (let j = i + 1; j < existingStones.length - 1; j += 1) {
            for (let k = j + 1; k < existingStones.length; k += 1) {
              const circle = computeCircle(existingStones[i], existingStones[j], existingStones[k]);
              if (!circle) continue;
              const diff = Math.abs(distance(circle.center, newPoint) - circle.radius);
              if (diff < tolerance) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function computeCircle(p1, p2, p3) {
        const d =
          2 *
          (p1.x * (p2.y - p3.y) +
            p2.x * (p3.y - p1.y) +
            p3.x * (p1.y - p2.y));
        if (Math.abs(d) < 1e-6) return null;
        const aSq = p1.x * p1.x + p1.y * p1.y;
        const bSq = p2.x * p2.x + p2.y * p2.y;
        const cSq = p3.x * p3.x + p3.y * p3.y;
        const ux =
          (aSq * (p2.y - p3.y) + bSq * (p3.y - p1.y) + cSq * (p1.y - p2.y)) / d;
        const uy =
          (aSq * (p3.x - p2.x) + bSq * (p1.x - p3.x) + cSq * (p2.x - p1.x)) / d;
        const center = { x: ux, y: uy };
        const radius = distance(center, p1);
        return Number.isFinite(radius) ? { center, radius } : null;
      }

      function distance(p1, p2) {
        return Math.hypot(p1.x - p2.x, p1.y - p2.y);
      }

      circleFirstPlayer.addEventListener('change', resetCircleGame);
      circleResetButton.addEventListener('click', resetCircleGame);
      buildCircleCells();
      updateScoreboard();
      updateAiStatsDisplay();
      resetCircleGame();

      // initial setup
      initializeFractal();
      resetHanoi();
    </script>
  </body>
</html>
