<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>電脳幾何空間</title>
    <style>
      :root {
        color-scheme: dark;
        --deck: 10deg;
        --neon: #0ff;
        --accent: #f0f;
        --deep: #090b1a;
        --grid: rgba(12, 46, 74, 0.7);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Inter", "游ゴシック体", sans-serif;
        background: radial-gradient(circle at top, rgba(12, 72, 114, 0.45), transparent 40%),
          linear-gradient(180deg, #02050b 0%, #0d0e1a 55%, #03050e 100%);
        color: #f5f5ff;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: linear-gradient(90deg, transparent 45%, rgba(255, 255, 255, 0.04) 50%),
          linear-gradient(180deg, transparent 45%, rgba(255, 255, 255, 0.03) 50%);
        background-size: 120px 120px;
        z-index: -2;
      }
      body::after {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(circle at 20% 20%, rgba(128, 255, 255, 0.08), transparent 40%),
          radial-gradient(circle at 80% 10%, rgba(244, 90, 255, 0.1), transparent 45%);
        z-index: -1;
        filter: blur(30px);
        opacity: 0.8;
      }
      main {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 2rem;
        padding: 2rem clamp(1rem, 4vw, 4rem) 4rem;
      }
      .panel {
        backdrop-filter: blur(24px);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 24px;
        padding: clamp(1.5rem, 3vw, 2.5rem);
        background: rgba(5, 9, 20, 0.75);
        box-shadow: 0 20px 60px rgba(2, 3, 7, 0.8);
      }
      h1,
      h2,
      h3 {
        font-weight: 600;
        line-height: 1.3;
      }
      .hero {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        position: relative;
        overflow: hidden;
      }
      .hero::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.12), transparent 50%);
        pointer-events: none;
      }
      .hero h1 {
        font-size: clamp(2.4rem, 4vw, 3.4rem);
      }
      .hero p {
        margin: 0;
        color: #cce3ff;
        max-width: 70ch;
      }
      .mode-selector {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      .mode-selector button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 999px;
        padding: 0.65rem 1.4rem;
        background: transparent;
        color: inherit;
        font-weight: 500;
        cursor: pointer;
        transition: border-color 0.2s ease, transform 0.2s ease;
      }
      .mode-selector button:hover {
        border-color: var(--neon);
        transform: translateY(-2px);
      }
      #fractal {
        display: grid;
        grid-template-columns: minmax(0, 360px) 1fr;
        gap: 2rem;
      }
      .fractal-info {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .fractal-grid {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .control-group {
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
        align-items: center;
        font-size: 0.95rem;
      }
      .control-group label {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        color: #9ab4ff;
      }
      .control-group input[type="range"] {
        width: 100%;
      }
      .control-row {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      canvas {
        width: 100%;
        height: 420px;
        border-radius: 18px;
        background: rgba(3, 6, 15, 0.85);
        box-shadow: inset 0 0 40px rgba(0, 255, 255, 0.08);
      }
      button.primary {
        align-self: flex-start;
        padding: 0.85rem 1.6rem;
        border-radius: 999px;
        border: none;
        background: linear-gradient(120deg, rgba(0, 255, 255, 0.25), rgba(255, 255, 255, 0.1));
        color: #f3ffff;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      }
      #constants {
        position: relative;
        overflow: hidden;
      }
      #constants::after {
        content: "";
        position: absolute;
        inset: 10% 0;
        background: repeating-linear-gradient(90deg, transparent 0 20px, rgba(255, 255, 255, 0.04) 21px 40px);
        opacity: 0.4;
      }
      .constants-display {
        position: relative;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
      }
      .constant-card {
        border-radius: 18px;
        padding: 1.2rem;
        background: rgba(2, 11, 32, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 10px 30px rgba(2, 4, 10, 0.8);
        min-height: 200px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
      .constant-card h3 {
        margin: 0;
        font-size: 1.2rem;
      }
      .constant-card p {
        margin: 0.8rem 0 0;
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 0.95rem;
        line-height: 1.5;
        white-space: pre-wrap;
        letter-spacing: 0.05em;
        color: #cce8ff;
      }
      #hanoi {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
      .hanoi-body {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
      }
      .tower-group {
        display: flex;
        flex: 1;
        justify-content: space-between;
        gap: 1rem;
      }
      .tower-column {
        flex: 1;
        min-width: 160px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        position: relative;
      }
      .tower-name {
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.2em;
        color: rgba(255, 255, 255, 0.7);
      }
      .tower {
        width: 100%;
        height: 210px;
        border-radius: 14px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(12, 18, 46, 0.8));
        border: 1px solid rgba(255, 255, 255, 0.08);
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        align-items: center;
        padding-bottom: 10px;
        box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.6);
      }
      .tower::after {
        content: "";
        position: absolute;
        width: 4px;
        height: 90%;
        background: rgba(255, 255, 255, 0.15);
        bottom: 10px;
        left: calc(50% - 2px);
        border-radius: 2px;
      }
      .disk {
        height: 18px;
        border-radius: 12px 12px 4px 4px;
        margin-bottom: 6px;
        transition: transform 0.3s ease;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
        position: relative;
      }
      .disk::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .tower-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
      }
      .tower-controls label {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        color: #b7c5ff;
      }
      .tower-controls select,
      .tower-controls input[type="range"] {
        appearance: none;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 0.5rem 0.75rem;
        color: inherit;
      }
      .hanoi-actions {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }
      .hanoi-actions button {
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 999px;
        padding: 0.65rem 1.2rem;
        background: transparent;
        color: #f3ffff;
        font-weight: 500;
        cursor: pointer;
      }
      .hanoi-actions button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .message {
        min-height: 1.4rem;
        font-size: 0.9rem;
        color: #9ab4ff;
      }
      @media (max-width: 900px) {
        #fractal {
          grid-template-columns: 1fr;
        }
      }
      @media (max-width: 600px) {
        .tower-group {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <section class="panel hero">
        <p class="eyebrow">電脳幾何空間</p>
        <h1>幾何学的な装飾と知的な遊び</h1>
        <p>
          こちらは線と光の言語で構成されたミステリアスなインターフェース。幾何学パターンの
         調整、定数の美しい浮遊、そして証明にも使われるハノイの塔まで、一つの流れにまとめました。
        </p>
        <div class="mode-selector">
          <button class="mode-button" data-target="fractal">フラクタルモード</button>
          <button class="mode-button" data-target="constants">定数表示</button>
          <button class="mode-button" data-target="hanoi">ハノイの塔</button>
        </div>
      </section>

      <section id="fractal" class="panel">
        <div class="fractal-info">
          <div>
            <h2>フラクタルで幾何学模様を自在に描く</h2>
            <p>
              分岐の角度や再帰の深さ、縮尺を操作しながら、空間に枝を伸ばしていく。選んだ色が
              ネオンのように幽玄な枝を染め上げます。
            </p>
          </div>
          <div class="fractal-grid">
            <div class="control-row">
              <label>
                深さ <span id="depthValue">6</span>
                <input type="range" id="depthRange" min="3" max="8" value="6" />
              </label>
              <label>
                角度 <span id="angleValue">30°</span>
                <input type="range" id="angleRange" min="15" max="60" value="30" />
              </label>
            </div>
            <div class="control-row">
              <label>
                縮尺 <span id="scaleValue">70%</span>
                <input type="range" id="scaleRange" min="50" max="85" value="70" />
              </label>
              <label>
                線の色
                <input type="color" id="branchColor" value="#00ffff" />
              </label>
            </div>
            <button class="primary" id="drawFractalBtn">生成</button>
          </div>
        </div>
        <canvas id="fractalCanvas" width="800" height="600"></canvas>
      </section>

      <section id="constants" class="panel">
        <h2>円周率とネイピア数の電脳詩</h2>
        <p>
          背景に浮かぶグリッドを透かして、π と e の数列がサイバーな光の帯となって流れてゆく。
          思考の奥にある普遍性を見つめてください。
        </p>
        <div class="constants-display">
          <article class="constant-card">
            <h3>π (Pi)</h3>
            <p id="piDigits"></p>
          </article>
          <article class="constant-card">
            <h3>e (ネイピア数)</h3>
            <p id="eDigits"></p>
          </article>
        </div>
      </section>

      <section id="hanoi" class="panel">
        <h2>ハノイの塔で論理を遊ぶ</h2>
        <p>
          解くには注意深い論理が必要。ディスクの枚数を変えて適応し、塔を移し替える感覚を直感的に確かめましょう。
        </p>
        <div class="hanoi-body">
          <div class="tower-group">
            <div class="tower-column">
              <span class="tower-name">塔 A</span>
              <div class="tower" data-index="0"></div>
            </div>
            <div class="tower-column">
              <span class="tower-name">塔 B</span>
              <div class="tower" data-index="1"></div>
            </div>
            <div class="tower-column">
              <span class="tower-name">塔 C</span>
              <div class="tower" data-index="2"></div>
            </div>
          </div>
          <div class="tower-controls">
            <label>
              ディスク数 <span id="diskCountValue">5</span>
              <input type="range" id="diskCount" min="3" max="7" value="5" />
            </label>
            <label>
              開始塔
              <select id="fromTower">
                <option value="0">A</option>
                <option value="1">B</option>
                <option value="2">C</option>
              </select>
            </label>
            <label>
              移動先
              <select id="toTower">
                <option value="0">A</option>
                <option value="1">B</option>
                <option value="2">C</option>
              </select>
            </label>
          </div>
          <div class="hanoi-actions">
            <button id="moveDisk">手動移動</button>
            <button id="autoSolve">自動で解く</button>
            <button id="resetHanoi">初期状態に戻す</button>
          </div>
          <p class="message" id="hanoiMessage">自由な手でディスクを移してください。</p>
        </div>
      </section>
    </main>

    <script>
      // Hero mode buttons scroll to sections
      document.querySelectorAll('.mode-button').forEach((button) => {
        button.addEventListener('click', () => {
          const targetId = button.getAttribute('data-target');
          document.getElementById(targetId).scrollIntoView({ behavior: 'smooth' });
        });
      });

      const depthRange = document.getElementById('depthRange');
      const angleRange = document.getElementById('angleRange');
      const scaleRange = document.getElementById('scaleRange');
      const depthValue = document.getElementById('depthValue');
      const angleValue = document.getElementById('angleValue');
      const scaleValue = document.getElementById('scaleValue');
      const branchColor = document.getElementById('branchColor');
      const fractalCanvas = document.getElementById('fractalCanvas');
      const ctx = fractalCanvas.getContext('2d');

      function syncRangeLabels() {
        depthValue.textContent = depthRange.value;
        angleValue.textContent = angleRange.value + '°';
        scaleValue.textContent = scaleRange.value + '%';
      }

      function resizeCanvas() {
        const rect = fractalCanvas.getBoundingClientRect();
        fractalCanvas.width = rect.width;
        fractalCanvas.height = rect.height;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }

      function drawBranch(x, y, length, angle, depth) {
        if (depth === 0) return;
        const x2 = x + Math.cos(angle) * length;
        const y2 = y + Math.sin(angle) * length;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x2, y2);
        ctx.lineWidth = Math.max(1, depth * 1.25);
        ctx.strokeStyle = branchColor.value;
        ctx.stroke();
        const nextLength = length * (scaleRange.value / 100);
        const branchAngle = (angleRange.value * Math.PI) / 180;
        drawBranch(x2, y2, nextLength, angle - branchAngle, depth - 1);
        drawBranch(x2, y2, nextLength, angle + branchAngle, depth - 1);
      }

      function renderFractal() {
        const width = fractalCanvas.width;
        const height = fractalCanvas.height;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = 'rgba(1, 2, 5, 0.65)';
        ctx.fillRect(0, 0, width, height);
        ctx.translate(width / 2, height * 0.9);
        const initialLength = height * 0.25;
        drawBranch(0, 0, initialLength, -Math.PI / 2, parseInt(depthRange.value, 10));
      }

      function initializeFractal() {
        syncRangeLabels();
        resizeCanvas();
        renderFractal();
      }

      window.addEventListener('resize', () => {
        resizeCanvas();
        renderFractal();
      });

      depthRange.addEventListener('input', () => {
        syncRangeLabels();
      });
      angleRange.addEventListener('input', () => {
        syncRangeLabels();
      });
      scaleRange.addEventListener('input', () => {
        syncRangeLabels();
      });

      document.getElementById('drawFractalBtn').addEventListener('click', () => {
        renderFractal();
      });

      // Constants display
      const piDigits =
        '3.14159265358979323846264338327950288419716939937510'
        + '58209749445923078164062862089986280348253421170679';
      const eDigits =
        '2.71828182845904523536028747135266249775724709369995'
        + '95749669676277240766303535475945713821785251664274';

      function chunkDigits(str) {
        const chunkSize = 20;
        const chunks = [];
        for (let i = 0; i < str.length; i += chunkSize) {
          chunks.push(str.slice(i, i + chunkSize));
        }
        return chunks.join('\n');
      }

      document.getElementById('piDigits').textContent = chunkDigits(piDigits);
      document.getElementById('eDigits').textContent = chunkDigits(eDigits);

      // Hanoi towers
      const diskCountInput = document.getElementById('diskCount');
      const diskCountValue = document.getElementById('diskCountValue');
      const fromSelect = document.getElementById('fromTower');
      const toSelect = document.getElementById('toTower');
      const moveButton = document.getElementById('moveDisk');
      const autoSolveButton = document.getElementById('autoSolve');
      const resetButton = document.getElementById('resetHanoi');
      const messageEl = document.getElementById('hanoiMessage');
      const towerEls = document.querySelectorAll('.tower');
      let towers = [[], [], []];
      let diskCount = parseInt(diskCountInput.value, 10);
      let autoTimer;

      function createDisks(count) {
        const stack = [];
        for (let i = count; i >= 1; i -= 1) {
          stack.push(i);
        }
        return stack;
      }

      function renderHanoi() {
        towerEls.forEach((towerEl) => {
          const idx = Number(towerEl.dataset.index);
          towerEl.innerHTML = '';
          const stack = towers[idx];
          stack.forEach((diskSize) => {
            const disk = document.createElement('div');
            disk.className = 'disk';
            const widthRatio = (diskSize / diskCount) * 0.7 + 0.3;
            disk.style.width = `${widthRatio * 100}%`;
            disk.style.background = `linear-gradient(90deg, rgba(0,255,255,0.4), rgba(255,0,255,0.4))`;
            towerEl.appendChild(disk);
          });
        });
      }

      function setMessage(text) {
        messageEl.textContent = text;
      }

      function resetHanoi() {
        if (autoTimer) {
          clearInterval(autoTimer);
          autoTimer = null;
        }
        diskCount = parseInt(diskCountInput.value, 10);
        diskCountValue.textContent = diskCount;
        towers = [createDisks(diskCount), [], []];
        renderHanoi();
        setMessage(`ディスク数 ${diskCount} で初期化されました。`);
      }

      function moveDisk(from, to, silent = false) {
        if (from === to) {
          if (!silent) setMessage('異なる塔を選んでください。');
          return false;
        }
        const source = towers[from];
        const target = towers[to];
        if (source.length === 0) {
          if (!silent) setMessage('開始塔にディスクがありません。');
          return false;
        }
        const disk = source[source.length - 1];
        const targetTop = target[target.length - 1];
        if (targetTop && disk > targetTop) {
          if (!silent) setMessage('大きなディスクを小さなディスクの上に置けません。');
          return false;
        }
        target.push(source.pop());
        renderHanoi();
        if (!silent) setMessage(`塔 ${String.fromCharCode(65 + from)} -> ${String.fromCharCode(65 + to)} に移動しました。`);
        return true;
      }

      function solveHanoi(n, from, to, aux, moves) {
        if (n === 0) return;
        solveHanoi(n - 1, from, aux, to, moves);
        moves.push([from, to]);
        solveHanoi(n - 1, aux, to, from, moves);
      }

      diskCountInput.addEventListener('input', () => {
        diskCountValue.textContent = diskCountInput.value;
      });

      moveButton.addEventListener('click', () => {
        const from = Number(fromSelect.value);
        const to = Number(toSelect.value);
        moveDisk(from, to);
      });

      autoSolveButton.addEventListener('click', () => {
        if (autoTimer) {
          clearInterval(autoTimer);
        }
        const moves = [];
        solveHanoi(diskCount, 0, 2, 1, moves);
        let index = 0;
        autoSolveButton.disabled = true;
        setMessage('自動解答を開始します。');
        autoTimer = setInterval(() => {
          if (index >= moves.length) {
            clearInterval(autoTimer);
            autoTimer = null;
            autoSolveButton.disabled = false;
            setMessage('自動解答が完了しました。');
            return;
          }
          const [from, to] = moves[index];
          moveDisk(from, to, true);
          index += 1;
        }, 420);
      });

      resetButton.addEventListener('click', () => {
        resetHanoi();
      });

      // initial setup
      initializeFractal();
      resetHanoi();
    </script>
  </body>
</html>
