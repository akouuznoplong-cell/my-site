<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>電脳幾何空間</title>
    <style>
      :root {
        color-scheme: dark;
        --deck: 10deg;
        --neon: #0ff;
        --accent: #f0f;
        --deep: #090b1a;
        --grid: rgba(12, 46, 74, 0.7);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Inter", "游ゴシック体", sans-serif;
        background: radial-gradient(circle at top, rgba(12, 72, 114, 0.45), transparent 40%),
          linear-gradient(180deg, #02050b 0%, #0d0e1a 55%, #03050e 100%);
        color: #f5f5ff;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: linear-gradient(90deg, transparent 45%, rgba(255, 255, 255, 0.04) 50%),
          linear-gradient(180deg, transparent 45%, rgba(255, 255, 255, 0.03) 50%);
        background-size: 120px 120px;
        z-index: -2;
      }
      body::after {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(circle at 20% 20%, rgba(128, 255, 255, 0.08), transparent 40%),
          radial-gradient(circle at 80% 10%, rgba(244, 90, 255, 0.1), transparent 45%);
        z-index: -1;
        filter: blur(30px);
        opacity: 0.8;
      }
      .formula-layer {
        position: fixed;
        inset: 0;
        z-index: -3;
        pointer-events: none;
        background:
          radial-gradient(circle at 60% 35%, rgba(0, 255, 255, 0.04), transparent 45%),
          radial-gradient(circle at 30% 50%, rgba(255, 0, 255, 0.03), transparent 40%),
          conic-gradient(from 60deg at 50% 40%, rgba(255, 255, 255, 0.08), transparent 40%);
        animation: rotateBackground 65s linear infinite;
        overflow: hidden;
      }
      .formula-layer svg {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0.35;
        mix-blend-mode: screen;
        animation: driftFormulas 50s linear infinite;
      }
      .formula-layer svg text {
        fill: rgba(255, 255, 255, 0.55);
        letter-spacing: 0.2em;
        font-family: "Source Code Pro", "Courier New", monospace;
      }
      .formula-layer svg circle,
      .formula-layer svg path {
        filter: drop-shadow(0 0 12px rgba(0, 255, 255, 0.35));
      }
      main {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 2rem;
        padding: 2rem clamp(1rem, 4vw, 4rem) 4rem;
      }
      .panel {
        backdrop-filter: blur(24px);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 24px;
        padding: clamp(1.5rem, 3vw, 2.5rem);
        background: rgba(5, 9, 20, 0.75);
        box-shadow: 0 20px 60px rgba(2, 3, 7, 0.8);
      }
      h1,
      h2,
      h3 {
        font-weight: 600;
        line-height: 1.3;
      }
      .hero {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        position: relative;
        overflow: hidden;
      }
      .hero::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.12), transparent 50%);
        pointer-events: none;
      }
      .hero h1 {
        font-size: clamp(2.4rem, 4vw, 3.4rem);
      }
      .hero p {
        margin: 0;
        color: #cce3ff;
        max-width: 70ch;
      }
      .mode-selector {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      .mode-selector button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 999px;
        padding: 0.65rem 1.4rem;
        background: transparent;
        color: inherit;
        font-weight: 500;
        cursor: pointer;
        transition: border-color 0.2s ease, transform 0.2s ease;
      }
      .mode-selector button:hover {
        border-color: var(--neon);
        transform: translateY(-2px);
      }
      #fractal {
        display: grid;
        grid-template-columns: minmax(0, 420px) minmax(0, 1fr);
        gap: clamp(1.5rem, 3vw, 2.75rem);
      }
      .toc-panel {
        display: grid;
        gap: 1.5rem;
      }
      .toc-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
        gap: 0.75rem;
      }
      .toc-card {
        position: relative;
        border-radius: 18px;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.08);
        cursor: pointer;
        overflow: hidden;
        transition: border-color 0.2s ease, transform 0.2s ease;
      }
      .toc-card:hover {
        border-color: rgba(0, 255, 255, 0.6);
        transform: translateY(-4px);
      }
      .toc-card span {
        display: block;
        font-size: 0.8rem;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: rgba(204, 232, 255, 0.6);
      }
      .toc-card strong {
        display: block;
        margin-top: 0.35rem;
        font-size: 1rem;
      }
      .toc-input {
        position: absolute;
        inset: 0;
        z-index: 1;
        opacity: 0;
        cursor: pointer;
      }
      .toc-dots {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 4px;
        margin-top: 0.75rem;
      }
      .toc-dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: rgba(0, 255, 255, 0.4);
        box-shadow: inset 0 0 4px rgba(255, 255, 255, 0.4);
        transition: transform 0.2s ease;
      }
      .toc-card:hover .toc-dot {
        transform: scale(1.2);
      }
      .fractal-info {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .fractal-grid {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .control-group {
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
        align-items: center;
        font-size: 0.95rem;
      }
      .control-group label {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        color: #9ab4ff;
      }
      .control-group input[type="range"] {
        width: 100%;
      }
      .control-row {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      canvas {
        width: 100%;
        height: clamp(480px, 55vw, 660px);
        border-radius: 18px;
        background: rgba(3, 6, 15, 0.85);
        box-shadow: inset 0 0 40px rgba(0, 255, 255, 0.08);
      }
      button.primary {
        align-self: flex-start;
        padding: 0.85rem 1.6rem;
        border-radius: 999px;
        border: none;
        background: linear-gradient(120deg, rgba(0, 255, 255, 0.25), rgba(255, 255, 255, 0.1));
        color: #f3ffff;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      }
      #constants {
        position: relative;
        overflow: hidden;
      }
      #constants::after {
        content: "";
        position: absolute;
        inset: 10% 0;
        background: repeating-linear-gradient(90deg, transparent 0 20px, rgba(255, 255, 255, 0.04) 21px 40px);
        opacity: 0.4;
      }
      .constant-history {
        font-size: 0.95rem;
        color: #9dbaff;
        margin: 0;
        line-height: 1.5;
      }
      .constant-digits {
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 1rem;
        letter-spacing: 0.18em;
        color: #cce8ff;
        background: rgba(4, 10, 28, 0.9);
        border-radius: 14px;
        padding: 1rem;
        border: 1px solid rgba(255, 255, 255, 0.08);
        min-height: 210px;
        max-height: 240px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-break: break-all;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.45);
      }
      .constants-display {
        position: relative;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
      }
      .constant-card {
        border-radius: 18px;
        padding: 1.2rem;
        background: rgba(2, 11, 32, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 10px 30px rgba(2, 4, 10, 0.8);
        min-height: 200px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      .approximation-panel {
        margin-top: 2rem;
        border-radius: 20px;
        padding: clamp(1.25rem, 2vw, 1.75rem);
        background: radial-gradient(circle at top, rgba(13, 55, 126, 0.25), transparent 60%),
          rgba(4, 10, 28, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 25px 55px rgba(1, 4, 12, 0.85);
      }
      .approximation-heading h3 {
        margin: 0;
        font-size: 1.4rem;
      }
      .approximation-heading p {
        margin: 0.4rem 0 0;
        color: #9dbaff;
        max-width: 60ch;
      }
      .approximation-grid {
        margin-top: 1.25rem;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
      }
      .approx-card {
        border-radius: 16px;
        padding: 1rem 1.1rem;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.05);
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
        position: relative;
        overflow: hidden;
      }
      .approx-card::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.01), transparent 60%);
        pointer-events: none;
        z-index: 0;
      }
      .approx-card-header {
        display: flex;
        flex-direction: column;
        color: #cce7ff;
        z-index: 1;
      }
      .approx-card-header span {
        font-size: 0.75rem;
        letter-spacing: 0.3em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.6);
      }
      .approx-card-header strong {
        font-size: 1.15rem;
        display: block;
        margin-top: 0.25rem;
      }
      .approx-formula {
        margin: 0;
        font-size: 0.85rem;
        color: #a1c4ff;
        font-family: "Source Code Pro", "Courier New", monospace;
        line-height: 1.4;
        z-index: 1;
      }
      .approx-value {
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 1.1rem;
        letter-spacing: 0.04em;
        color: #e3faff;
        z-index: 1;
      }
      .approx-progress {
        width: 100%;
        height: 4px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
        overflow: hidden;
        position: relative;
        z-index: 1;
      }
      .approx-progress-bar {
        height: 100%;
        display: block;
        background: linear-gradient(90deg, rgba(0, 255, 255, 0.8), rgba(255, 255, 255, 0.05));
        transition: width 0.2s ease;
      }
      .approx-meta {
        display: flex;
        justify-content: space-between;
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.7);
        z-index: 1;
      }
      .approx-iteration {
        font-size: 0.75rem;
        color: #9ab4ff;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        z-index: 1;
      }
      .approx-caption {
        margin: 0;
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.65);
        min-height: 2rem;
        z-index: 1;
      }
      .constant-card h3 {
        margin: 0;
        font-size: 1.2rem;
      }
      .constant-card p {
        margin: 0.8rem 0 0;
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 0.95rem;
        line-height: 1.5;
        white-space: pre-wrap;
        letter-spacing: 0.05em;
        color: #cce8ff;
      }
      #hanoi {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
      .hanoi-body {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
      }
      .tower-group {
        display: flex;
        flex: 1;
        justify-content: space-between;
        gap: 1rem;
      }
      .tower-column {
        flex: 1;
        min-width: 160px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        position: relative;
      }
      .tower-name {
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.2em;
        color: rgba(255, 255, 255, 0.7);
      }
      .tower {
        width: 100%;
        height: 210px;
        border-radius: 14px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(12, 18, 46, 0.8));
        border: 1px solid rgba(255, 255, 255, 0.08);
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        align-items: center;
        padding-bottom: 10px;
        box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.6);
        cursor: grab;
        transition: border-color 0.25s ease, box-shadow 0.25s ease, transform 0.25s ease;
      }
      .tower::after {
        content: "";
        position: absolute;
        width: 4px;
        height: 90%;
        background: rgba(255, 255, 255, 0.15);
        bottom: 10px;
        left: calc(50% - 2px);
        border-radius: 2px;
      }
      .tower:active {
        cursor: grabbing;
      }
      .tower-drag-source {
        border-color: var(--neon);
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.4), inset 0 0 35px rgba(255, 255, 255, 0.1);
      }
      .tower-drag-target {
        border-color: var(--accent);
        box-shadow: 0 0 30px rgba(244, 90, 255, 0.35), inset 0 0 28px rgba(255, 255, 255, 0.08);
      }
      .disk {
        height: 18px;
        border-radius: 12px 12px 4px 4px;
        margin-bottom: 6px;
        transition: transform 0.3s ease;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
        position: relative;
      }
      .disk::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .tower-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
      }
      .tower-controls label {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        color: #b7c5ff;
      }
      .tower-controls select,
      .tower-controls input[type="range"] {
        appearance: none;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 0.5rem 0.75rem;
        color: inherit;
      }
      .hanoi-actions {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }
      .hanoi-actions button {
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 999px;
        padding: 0.65rem 1.2rem;
        background: transparent;
        color: #f3ffff;
        font-weight: 500;
        cursor: pointer;
      }
      .hanoi-actions button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .message {
        min-height: 1.4rem;
        font-size: 0.9rem;
        color: #9ab4ff;
      }
      #circleGame {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .circle-game {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        align-items: flex-start;
        justify-content: space-between;
      }
      .circle-board {
        --board-size: 9;
        position: relative;
        min-width: 320px;
        width: min(520px, 100%);
        aspect-ratio: 1 / 1;
        border-radius: 18px;
        padding: 1rem;
        background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.08), transparent 60%),
          linear-gradient(90deg, rgba(255, 255, 255, 0.08) 1px, transparent 1px),
          linear-gradient(rgba(255, 255, 255, 0.08) 1px, transparent 1px);
        background-size: calc(100% / (var(--board-size) - 1)) calc(100% / (var(--board-size) - 1));
        display: grid;
        grid-template-columns: repeat(var(--board-size), 1fr);
        grid-template-rows: repeat(var(--board-size), 1fr);
        gap: 0;
        box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.7), 0 30px 50px rgba(5, 8, 25, 0.7);
      }
      #circleOverlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
        width: 100%;
        height: 100%;
      }
      .circle-cell {
        border: none;
        background: transparent;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        transition: transform 0.15s ease, opacity 0.2s ease;
      }
      .circle-cell::after {
        content: "";
        position: absolute;
        inset: 50%;
        transform: translate(-50%, -50%);
        width: 6px;
        height: 6px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.12);
        pointer-events: none;
      }
      .circle-cell .stone {
        width: 58%;
        height: 58%;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.4);
        box-shadow: 0 0 12px rgba(0, 255, 255, 0.35);
        transition: background 0.25s ease, box-shadow 0.25s ease;
      }
      .circle-cell[data-player="0"] .stone {
        opacity: 0;
        box-shadow: none;
      }
      .circle-cell[data-player="1"] .stone {
        background: radial-gradient(circle, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.6));
      }
      .circle-cell[data-player="2"] .stone {
        background: radial-gradient(circle, rgba(244, 90, 255, 0.85), rgba(244, 90, 255, 0.4));
      }
      .circle-cell.circle-cell--last {
        transform: scale(1.05);
      }
      .circle-game-info {
        flex: 1;
        min-width: 240px;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .circle-scoreboard {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.75rem;
      }
      .circle-scoreboard div {
        padding: 0.9rem;
        border-radius: 14px;
        background: rgba(10, 26, 50, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.4);
      }
      .circle-scoreboard strong {
        display: block;
        font-size: 0.85rem;
        letter-spacing: 0.2em;
        color: rgba(255, 255, 255, 0.6);
        margin-bottom: 0.35rem;
      }
      .circle-scoreboard--wide {
        grid-column: 1 / -1;
      }
      .circle-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      .circle-controls label,
      .circle-controls button {
        font-size: 0.9rem;
      }
      .circle-controls select,
      .circle-controls button {
        appearance: none;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.05);
        color: inherit;
        padding: 0.5rem 0.9rem;
      }
      .circle-controls button {
        cursor: pointer;
      }
      .circle-message {
        min-height: 2rem;
        font-size: 0.95rem;
        color: #cbe8ff;
      }
      .circle-ai-info {
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.7);
        margin: 0;
      }
      @keyframes driftFormulas {
        0% {
          transform: translate(0%, 0%);
        }
        100% {
          transform: translate(-15%, -10%);
        }
      }
      @keyframes rotateBackground {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      @media (max-width: 900px) {
        #fractal {
          grid-template-columns: 1fr;
        }
      }
      @media (max-width: 600px) {
        .tower-group {
          flex-direction: column;
        }
      }
      #mathIntroOverlay {
        position: fixed;
        inset: 0;
        background: radial-gradient(circle at 30% 30%, rgba(10, 141, 255, 0.25), transparent 50%),
          radial-gradient(circle at 70% 20%, rgba(255, 82, 255, 0.18), transparent 55%),
          rgba(2, 5, 12, 0.95);
        overflow: hidden;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        padding: 1rem;
        gap: 1rem;
        transition: opacity 0.8s ease;
      }
      #mathIntroOverlay::before {
        content: "";
        position: absolute;
        inset: 8%;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 30px;
        pointer-events: none;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
      }
      #mathIntroOverlay.math-intro-hidden {
        opacity: 0;
        pointer-events: none;
      }
      #mathIntroCanvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }
      .math-intro-copy {
        position: relative;
        z-index: 10;
        text-align: center;
        max-width: 80ch;
      }
      .math-intro-copy h2 {
        margin: 0 0 0.25rem;
        font-size: clamp(1.5rem, 3vw, 2.4rem);
      }
      .math-intro-copy p {
        margin: 0;
        color: rgba(255, 255, 255, 0.85);
      }
      .math-intro-copy .math-intro-tagline {
        margin-top: 0.5rem;
        letter-spacing: 0.3em;
        font-size: 0.75rem;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.55);
      }
      .math-intro-copy small {
        display: inline-block;
        margin-top: 0.5rem;
        font-size: 0.75rem;
        letter-spacing: 0.3em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.6);
      }
    </style>
  </head>
  <body>
    <div id="mathIntroOverlay" aria-label="数学的オープニング">
      <canvas id="mathIntroCanvas"></canvas>
      <div class="math-intro-copy">
        <h2>Deep Dive into Numbers</h2>
        <p>立体的な軌道が渦巻き、螺旋の奥へと吸い込まれるように、数学の深淵へと誘います。自動で収束する演算のリズムとともに、次第に現れた真理の光がページを照らします。</p>
        <span class="math-intro-tagline">Descend · Accelerate · Illuminate</span>
        <small>Click anywhere to jump forward</small>
      </div>
    </div>
    <div class="formula-layer" aria-hidden="true">
      <svg viewBox="0 0 720 240" preserveAspectRatio="xMidYMid slice">
        <text x="20" y="50" font-size="32">∑_{n=1}^∞ 1/n^2 = π^2/6</text>
        <text x="20" y="100" font-size="32">e^{iπ} + 1 = 0</text>
        <text x="20" y="150" font-size="26">ζ(s) = ∑_{n=1}^∞ 1/n^s</text>
        <text x="20" y="200" font-size="26">f(z)=z^2+c ... フラクタル軌跡</text>
        <circle cx="540" cy="120" r="60" stroke-width="1.5" stroke="rgba(255,255,255,0.25)" fill="none" />
        <circle cx="600" cy="60" r="32" stroke-width="0.6" stroke="rgba(0,255,255,0.4)" fill="none" />
        <path d="M420 40 Q 470 20 520 60" stroke="rgba(255,255,255,0.4)" stroke-width="1" fill="none" />
      </svg>
    </div>
    <main>
      <section class="panel hero">
        <p class="eyebrow">知の探求</p>
        <h1>幾何学的な装飾と知的な遊び</h1>
        <p>
          こちらは線と光の言語で構成されたミステリアスなインターフェース。幾何学パターンの
         調整、定数の美しい浮遊、そして証明にも使われるハノイの塔まで、一つの流れにまとめました。
        </p>
        <div class="mode-selector">
          <button class="mode-button" data-target="fractal">フラクタルモード</button>
          <button class="mode-button" data-target="constants">定数表示</button>
          <button class="mode-button" data-target="hanoi">ハノイの塔</button>
        </div>
      </section>

      <section class="panel toc-panel">
        <div>
          <h2>目次</h2>
          <p>各セクションへ格子状に配置したドットを選んで移動します。円状のゲームもここからすぐに。</p>
        </div>
        <div class="toc-grid">
          <label class="toc-card">
            <input class="toc-input" type="button" data-target="fractal" />
            <span>フラクタル</span>
            <strong>幾何学模様</strong>
            <div class="toc-dots">
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
            </div>
          </label>
          <label class="toc-card">
            <input class="toc-input" type="button" data-target="constants" />
            <span>定数群</span>
            <strong>π と e</strong>
            <div class="toc-dots">
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
            </div>
          </label>
          <label class="toc-card">
            <input class="toc-input" type="button" data-target="hanoi" />
            <span>論理遊び</span>
            <strong>ハノイの塔</strong>
            <div class="toc-dots">
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
            </div>
          </label>
          <label class="toc-card">
            <input class="toc-input" type="button" data-target="circleGame" />
            <span>円状ゲーム</span>
            <strong>4点を避ける</strong>
            <div class="toc-dots">
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
              <span class="toc-dot"></span>
            </div>
          </label>
        </div>
      </section>

      <section id="fractal" class="panel">
        <div class="fractal-info">
          <div>
            <h2>フラクタルで幾何学模様を自在に描く</h2>
            <p>
              分岐の角度や再帰の深さ、縮尺を操作しながら、空間に枝を伸ばしていく。選んだ色が
              ネオンのように幽玄な枝を染め上げます。
            </p>
          </div>
          <div class="fractal-grid">
            <div class="control-row">
              <label>
                フラクタルタイプ
                <select id="fractalType">
                  <option value="tree">枝分かれの森</option>
                  <option value="triangle">シェルピンスキーの三角形</option>
                  <option value="spiral">渦巻く黄金スパイラル</option>
                </select>
              </label>
              <label>
                線の色
                <input type="color" id="branchColor" value="#00ffff" />
              </label>
            </div>
            <div class="control-row">
              <label>
                深さ <span id="depthValue">6</span>
                <input type="range" id="depthRange" min="3" max="8" value="6" />
              </label>
              <label>
                角度 <span id="angleValue">30°</span>
                <input type="range" id="angleRange" min="15" max="60" value="30" />
              </label>
            </div>
            <div class="control-row">
              <label>
                縮尺 <span id="scaleValue">70%</span>
                <input type="range" id="scaleRange" min="50" max="85" value="70" />
              </label>
              <label>
                枝の数 <span id="branchCountValue">3</span>
                <input type="range" id="branchFactorRange" min="2" max="5" value="3" />
              </label>
            </div>
          </div>
        </div>
        <canvas id="fractalCanvas" width="800" height="600"></canvas>
      </section>

      <section id="constants" class="panel">
        <h2>円周率とネイピア数の電脳詩</h2>
        <p>
          背景に浮かぶグリッドを透かして、π と e の数列がサイバーな光の帯となって流れてゆく。
          思考の奥にある普遍性を見つめてください。
        </p>
        <div class="constants-display">
          <article class="constant-card">
            <h3>π (Pi)</h3>
            <p class="constant-history">
              紀元前2000年ごろ、バビロニアとエジプトの数学者たちが円の周りを測り、古代の近似値を発見しました。
              アルキメデスは正多角形で内接・外接してπの上下限を導き、無限の理想へと探査を広げました。
            </p>
            <p class="constant-history">
              以降も文化を超えてπは天文学や物理学に浸透し、計算の歴史は桁数を追い求める旅へと続きます。
            </p>
            <pre class="constant-digits" id="piDigits" aria-label="円周率の桁"></pre>
          </article>
          <article class="constant-card">
            <h3>e (ネイピア数)</h3>
            <p class="constant-history">
              ジョン・ネイピア（1550-1617）は自然対数の概念とともに、この成長率の定数を提示しました。
              その後、解析学者たちは微分積分や連続複利の裏側にeを見出し、数学の軸に据えました。
            </p>
            <p class="constant-history">
              現代ではオイラーの公式や無限級数として鮮烈な姿を見せ、虚数単位と美しく結びついています。
            </p>
            <pre class="constant-digits" id="eDigits" aria-label="ネイピア数の桁"></pre>
          </article>
        </div>
        <div class="approximation-panel">
          <div class="approximation-heading">
            <h3>高速な近似の瞬間</h3>
            <p>桁をひとつずつ並べるのではなく、アルゴリズム的に跳躍的に収束する演算の熱を可視化しています。目には映らない計算機の鼓動をドットに映し、π と e を高速で演算する近似式の魅力を体感してください。</p>
          </div>
          <div class="approximation-grid">
            <article class="approx-card">
              <div class="approx-card-header">
                <span>π</span>
                <strong>Gauss–Legendre</strong>
              </div>
              <p class="approx-formula" id="piFormula"></p>
              <div class="approx-value" id="piApproxValue"></div>
              <div class="approx-progress">
                <span id="piApproxProgress" class="approx-progress-bar"></span>
              </div>
              <div class="approx-meta">
                <span>桁数 <strong id="piApproxDigits">0</strong></span>
                <span class="approx-speed">Quadratic convergence</span>
              </div>
              <div class="approx-iteration" id="piIteration">Iteration 01</div>
              <p class="approx-caption" id="piCaption"></p>
            </article>
            <article class="approx-card">
              <div class="approx-card-header">
                <span>e</span>
                <strong>Σ 1/n!</strong>
              </div>
              <p class="approx-formula" id="eFormula"></p>
              <div class="approx-value" id="eApproxValue"></div>
              <div class="approx-progress">
                <span id="eApproxProgress" class="approx-progress-bar"></span>
              </div>
              <div class="approx-meta">
                <span>桁数 <strong id="eApproxDigits">0</strong></span>
                <span class="approx-speed">Factorial decay</span>
              </div>
              <div class="approx-iteration" id="eIteration">Iteration 01</div>
              <p class="approx-caption" id="eCaption"></p>
            </article>
          </div>
        </div>
      </section>

      <section id="hanoi" class="panel">
        <h2>ハノイの塔で論理を遊ぶ</h2>
        <p>
          解くには注意深い論理が必要。ディスクの枚数を変えて適応し、塔を移し替える感覚を直感的に確かめましょう。
        </p>
        <div class="hanoi-body">
          <div class="tower-group">
            <div class="tower-column">
              <span class="tower-name">塔 A</span>
              <div class="tower" data-index="0"></div>
            </div>
            <div class="tower-column">
              <span class="tower-name">塔 B</span>
              <div class="tower" data-index="1"></div>
            </div>
            <div class="tower-column">
              <span class="tower-name">塔 C</span>
              <div class="tower" data-index="2"></div>
            </div>
          </div>
          <div class="tower-controls">
            <label>
              ディスク数 <span id="diskCountValue">5</span>
              <input type="range" id="diskCount" min="3" max="7" value="5" />
            </label>
            <label>
              開始塔
              <select id="fromTower">
                <option value="0">A</option>
                <option value="1">B</option>
                <option value="2">C</option>
              </select>
            </label>
            <label>
              移動先
              <select id="toTower">
                <option value="0">A</option>
                <option value="1">B</option>
                <option value="2">C</option>
              </select>
            </label>
          </div>
          <div class="hanoi-actions">
            <button id="moveDisk">手動移動</button>
            <button id="autoSolve">自動で解く</button>
            <button id="resetHanoi">初期状態に戻す</button>
          </div>
      <p class="message" id="hanoiMessage">自由な手でディスクを移してください。</p>
        </div>
      </section>

      <section id="circleGame" class="panel">
        <h2>円を避ける碁盤の学習対戦</h2>
        <p>
          囲碁の交差点を舞台に、先攻と後攻が交互に石を置いてゆきます。既存の3点が描く円の円周上に
          4点目を置くと失敗。AIは対戦の結果を蓄積しながら、ユーザーの選択を学習していきます。
        </p>
        <div class="circle-game">
          <div id="circleBoard" class="circle-board" role="grid" aria-label="円を避けるゲームの碁盤">
            <svg id="circleOverlay" viewBox="0 0 9 9" preserveAspectRatio="xMidYMid meet" aria-hidden="true"></svg>
          </div>
          <div class="circle-game-info">
            <div class="circle-scoreboard">
              <div>
                <strong>あなた</strong>
                <span id="circleHumanScore">0 勝</span>
              </div>
              <div>
                <strong>AI</strong>
                <span id="circleAiScore">0 勝</span>
              </div>
              <div class="circle-scoreboard--wide">
                <strong>引き分け</strong>
                <span id="circleDraws">0 回</span>
              </div>
            </div>
            <div class="circle-controls">
              <label>
                先攻
                <select id="circleFirstPlayer">
                  <option value="human">あなた</option>
                  <option value="ai">AI</option>
                </select>
              </label>
              <button type="button" id="circleReset">盤面をリセット</button>
            </div>
            <p class="circle-message" id="circleMessage">
              線上に4点をつくらないように気をつけながら石を置いてください。
            </p>
            <p class="circle-ai-info" id="circleAiInfo">
              AIは対戦データを蓄積中。初期の探索ではランダムに打つこともあります。
            </p>
          </div>
        </div>
      </section>
    </main>

    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js';

      const overlay = document.getElementById('mathIntroOverlay');
      const canvas = document.getElementById('mathIntroCanvas');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setClearColor(0x01030a, 0);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x02060e, 0.028);

      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1200);
      camera.position.set(0, 0, 32);

      const ambient = new THREE.AmbientLight(0x0b1d36, 1.6);
      scene.add(ambient);
      const pointLight = new THREE.PointLight(0x84fbff, 1.8, 180);
      pointLight.position.set(12, 12, 22);
      scene.add(pointLight);

      const ribbonGroup = new THREE.Group();
      const colors = [0x76f1ff, 0xff76c7, 0xa9f8ff, 0xffb15f];
      for (let i = 0; i < 5; i += 1) {
        const radius = 5.8 - i * 0.5;
        const thickness = 0.22 + i * 0.04;
        const segments = 220;
        const torusKnot = new THREE.TorusKnotGeometry(radius, thickness, segments, 30, 2 + i * 0.3, 3 + i * 0.4);
        const material = new THREE.MeshStandardMaterial({
          color: colors[i % colors.length],
          emissive: 0x090b1e,
          emissiveIntensity: 0.7,
          metalness: 0.8,
          roughness: 0.25,
          transparent: true,
          opacity: 0.88 - i * 0.08,
          side: THREE.DoubleSide,
        });
        const mesh = new THREE.Mesh(torusKnot, material);
        mesh.rotation.x = Math.PI / 2;
        mesh.position.z = -i * 2.6;
        ribbonGroup.add(mesh);
      }
      scene.add(ribbonGroup);

      const haloRing = new THREE.Mesh(
        new THREE.RingGeometry(6.5, 11.5, 96),
        new THREE.MeshBasicMaterial({
          color: 0x4ae1ff,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.2,
        })
      );
      haloRing.rotation.x = Math.PI / 2;
      haloRing.position.z = -16;
      scene.add(haloRing);

      const beamGroup = new THREE.Group();
      const beamMaterial = new THREE.MeshBasicMaterial({ color: 0x70f2ff, transparent: true, opacity: 0.24 });
      for (let i = 0; i < 18; i += 1) {
        const geometry = new THREE.CylinderGeometry(0.02, 0.02, 20, 8, 1, true);
        const beam = new THREE.Mesh(geometry, beamMaterial);
        beam.rotation.z = Math.PI / 2;
        const angle = (i / 18) * Math.PI * 2;
        beam.position.x = Math.cos(angle) * 3.3;
        beam.position.y = Math.sin(angle) * 3.3;
        beam.position.z = -6 - i * 0.5;
        beam.rotation.y = angle;
        beamGroup.add(beam);
      }
      scene.add(beamGroup);

      const trailCount = 780;
      const trailGeometry = new THREE.BufferGeometry();
      const trailPositions = new Float32Array(trailCount * 3);
      for (let i = 0; i < trailCount; i += 1) {
        trailPositions[i * 3] = (Math.random() - 0.5) * 24;
        trailPositions[i * 3 + 1] = (Math.random() - 0.5) * 24;
        trailPositions[i * 3 + 2] = -Math.random() * 40;
      }
      trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      const trailMaterial = new THREE.PointsMaterial({
        color: 0x70ddff,
        size: 0.08,
        transparent: true,
        opacity: 0.95,
      });
      const trails = new THREE.Points(trailGeometry, trailMaterial);
      scene.add(trails);

      const sparkleGeometry = new THREE.SphereGeometry(0.15, 16, 10);
      const sparkleMaterial = new THREE.MeshBasicMaterial({ color: 0xfff1c4 });
      const sparkleGroup = new THREE.Group();
      for (let i = 0; i < 12; i += 1) {
        const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
        sparkle.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, -Math.random() * 30);
        sparkleGroup.add(sparkle);
      }
      scene.add(sparkleGroup);

      const baseZ = 32;
      let running = true;
      const introDuration = 15000;
      const fadeBuffer = 900;

      const updateTrails = (speed) => {
        const positions = trailGeometry.attributes.position.array;
        for (let i = 0; i < trailCount; i += 1) {
          positions[i * 3 + 2] += speed;
          if (positions[i * 3 + 2] > 2) {
            positions[i * 3 + 2] = -38;
            positions[i * 3] = (Math.random() - 0.5) * 24;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 24;
          }
        }
        trailGeometry.attributes.position.needsUpdate = true;
      };

      const updateSparkles = (time) => {
        sparkleGroup.children.forEach((sparkle, idx) => {
          sparkle.position.z += 0.05 + idx * 0.002;
          sparkle.position.y = Math.sin(time * 0.7 + idx) * 2.2;
          if (sparkle.position.z > 2) {
            sparkle.position.z = -35;
            sparkle.position.x = (Math.random() - 0.5) * 10;
          }
        });
      };

      const clock = new THREE.Clock();
      const animate = () => {
        if (!running) return;
        requestAnimationFrame(animate);
        const elapsed = clock.getElapsedTime();
        ribbonGroup.rotation.z += 0.012;
        ribbonGroup.rotation.y = Math.sin(elapsed * 0.8) * 0.3;
        haloRing.rotation.z -= 0.004;
        beamGroup.rotation.y += 0.03;
        updateTrails(0.34);
        updateSparkles(elapsed);
        const travel = Math.min(20, elapsed * 3);
        camera.position.z = baseZ - travel;
        camera.position.y = Math.sin(elapsed * 0.9) * 2.1;
        camera.lookAt(0, 0, -travel * 0.7);
        renderer.render(scene, camera);
        if (elapsed * 1000 > introDuration) {
          hideOverlay(true);
        }
      };

      const handleResize = () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      };
      window.addEventListener('resize', handleResize);

      const hideOverlay = (auto = false) => {
        if (!running) return;
        running = false;
        overlay.classList.add('math-intro-hidden');
        setTimeout(() => {
          overlay.remove();
        }, fadeBuffer);
        if (!auto) {
          setTimeout(() => {
            renderer.forceContextLoss();
          }, fadeBuffer + 200);
        }
      };

      overlay.addEventListener('click', () => hideOverlay());
      setTimeout(() => hideOverlay(true), introDuration + fadeBuffer);

      animate();
    </script>

    <script>
      // Hero mode buttons & table-of-contents dots scroll to sections
      function installScrollLinks(selector) {
        document.querySelectorAll(selector).forEach((button) => {
          button.addEventListener('click', () => {
            const targetId = button.getAttribute('data-target');
            document.getElementById(targetId).scrollIntoView({ behavior: 'smooth' });
          });
        });
      }

      installScrollLinks('.mode-button');
      installScrollLinks('.toc-input');

      const depthRange = document.getElementById('depthRange');
      const angleRange = document.getElementById('angleRange');
      const scaleRange = document.getElementById('scaleRange');
      const branchFactorRange = document.getElementById('branchFactorRange');
      const depthValue = document.getElementById('depthValue');
      const angleValue = document.getElementById('angleValue');
      const scaleValue = document.getElementById('scaleValue');
      const branchCountValue = document.getElementById('branchCountValue');
      const branchColor = document.getElementById('branchColor');
      const fractalTypeSelect = document.getElementById('fractalType');
      const fractalCanvas = document.getElementById('fractalCanvas');
      const ctx = fractalCanvas.getContext('2d');

      const fractalMotion = {
        currentX: 0,
        currentY: 0,
        currentRotation: 0,
        targetX: 0,
        targetY: 0,
        targetRotation: 0,
      };
      let fractalAnimationId;
      let approxInterval;
      let piApproxPointer = 5;
      let eApproxPointer = 5;

      const piDigits =
        '3.14159265358979323846264338327950288419716939937510'
        + '58209749445923078164062862089986280348253421170679';
      const eDigits =
        '2.71828182845904523536028747135266249775724709369995'
        + '95749669676277240766303535475945713821785251664274';
      const piDisplay = document.getElementById('piDigits');
      const eDisplay = document.getElementById('eDigits');
      const piApproxValue = document.getElementById('piApproxValue');
      const eApproxValue = document.getElementById('eApproxValue');
      const piApproxDigits = document.getElementById('piApproxDigits');
      const eApproxDigits = document.getElementById('eApproxDigits');
      const piApproxProgress = document.getElementById('piApproxProgress');
      const eApproxProgress = document.getElementById('eApproxProgress');
      const piIterationLabel = document.getElementById('piIteration');
      const eIterationLabel = document.getElementById('eIteration');
      const piFormulaEl = document.getElementById('piFormula');
      const eFormulaEl = document.getElementById('eFormula');
      const piCaptionEl = document.getElementById('piCaption');
      const eCaptionEl = document.getElementById('eCaption');
      const approxInfo = {
        pi: {
          digits: piDigits,
          formula: 'a_{n+1} = (a_n + b_n)/2, b_{n+1} = sqrt(a_n b_n), t_{n+1} = t_n - p_n(a_n - a_{n+1})^2',
          caption: 'Gauss–Legendre 式はAGM 演算を使い、齊次平均と平方根を交互に計算して桁数を二乗で増やします。',
        },
        e: {
          digits: eDigits,
          formula: 'e = Σ_{k=0}^∞ 1/k!',
          caption: '階乗の逆数を足し合わせるだけで収束するため、CPU はごく少ないステップで多くの桁を確定します。',
        },
      };
      piFormulaEl.textContent = approxInfo.pi.formula;
      eFormulaEl.textContent = approxInfo.e.formula;
      piCaptionEl.textContent = approxInfo.pi.caption;
      eCaptionEl.textContent = approxInfo.e.caption;

      function formatConstantDigits(str) {
        const groupSize = 60;
        const groups = [];
        for (let i = 0; i < str.length; i += groupSize) {
          groups.push(str.slice(i, i + groupSize));
        }
        return groups.join('\n');
      }

      function animateApproximations() {
        piApproxPointer += Math.floor(Math.random() * 3) + 1;
        eApproxPointer += Math.floor(Math.random() * 2) + 1;
        if (piApproxPointer > approxInfo.pi.digits.length) {
          piApproxPointer = 5;
        }
        if (eApproxPointer > approxInfo.e.digits.length) {
          eApproxPointer = 5;
        }
        const piSegment = approxInfo.pi.digits.slice(0, piApproxPointer);
        const eSegment = approxInfo.e.digits.slice(0, eApproxPointer);
        piApproxValue.textContent = piSegment;
        eApproxValue.textContent = eSegment;
        piApproxDigits.textContent = piApproxPointer;
        eApproxDigits.textContent = eApproxPointer;
        piApproxProgress.style.width = `${(piApproxPointer / approxInfo.pi.digits.length) * 100}%`;
        eApproxProgress.style.width = `${(eApproxPointer / approxInfo.e.digits.length) * 100}%`;
        piIterationLabel.textContent = `STEP ${String(Math.min(15, Math.floor(piApproxPointer / 4) + 1)).padStart(2, '0')}`;
        eIterationLabel.textContent = `STEP ${String(Math.min(15, Math.floor(eApproxPointer / 3) + 1)).padStart(2, '0')}`;
      }

      function startApproximationLoop() {
        if (approxInterval) {
          clearInterval(approxInterval);
        }
        animateApproximations();
        approxInterval = setInterval(animateApproximations, 240);
      }

      function updateControlLabels() {
        depthValue.textContent = depthRange.value;
        angleValue.textContent = `${angleRange.value}°`;
        scaleValue.textContent = `${scaleRange.value}%`;
        branchCountValue.textContent = branchFactorRange.value;
      }

      function updateMotionTargets() {
        const scaleNorm = parseFloat(scaleRange.value) / 100;
        const angleInput = parseInt(angleRange.value, 10);
        const branchFactor = parseInt(branchFactorRange.value, 10);
        const fractalType = fractalTypeSelect.value;
        const typeBias = fractalType === 'spiral' ? 1.3 : fractalType === 'triangle' ? 1.0 : 0.75;
        fractalMotion.targetX = (scaleNorm - 0.63) * 210 * typeBias;
        fractalMotion.targetY = (angleInput - 32) * 1.15 * typeBias;
        fractalMotion.targetRotation = (branchFactor - 3) * 0.018 * typeBias;
      }

      function advanceMotion() {
        const smoothing = 0.08;
        fractalMotion.currentX += (fractalMotion.targetX - fractalMotion.currentX) * smoothing;
        fractalMotion.currentY += (fractalMotion.targetY - fractalMotion.currentY) * smoothing;
        fractalMotion.currentRotation +=
          (fractalMotion.targetRotation - fractalMotion.currentRotation) * smoothing;
      }

      function resizeCanvas() {
        const rect = fractalCanvas.getBoundingClientRect();
        fractalCanvas.width = rect.width;
        fractalCanvas.height = rect.height;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }

      function drawBranch(ctx, x, y, length, angle, depth, opts) {
        if (depth === 0 || length < 2) return;
        const x2 = x + Math.cos(angle) * length;
        const y2 = y + Math.sin(angle) * length;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x2, y2);
        ctx.lineWidth = Math.max(1, depth * 1.4);
        ctx.strokeStyle = opts.color;
        ctx.stroke();
        const nextLength = length * (opts.scale * 0.92);
        const children = Math.max(2, opts.branchFactor);
        const baseSpread = opts.branchSpread;
        for (let i = 0; i < children; i += 1) {
          const offset = children === 1 ? 0 : (i / (children - 1) - 0.5);
          const jitter = Math.sin(depth * 0.45 + i) * 0.07;
          const subAngle = angle + offset * baseSpread + offset * jitter;
          drawBranch(ctx, x2, y2, nextLength, subAngle, depth - 1, opts);
        }
      }

      function drawBinaryTree(ctx, opts) {
        const motion = opts.motion || {};
        const offsetX = motion.x || 0;
        const offsetY = motion.y || 0;
        const rotation = motion.rotation || 0;
        ctx.save();
        ctx.translate(opts.width / 2 + offsetX, opts.height * 0.9 + offsetY);
        ctx.rotate(rotation);
        drawBranch(ctx, 0, 0, opts.height * 0.25 * opts.scale, -Math.PI / 2, opts.depth, opts);
        ctx.restore();
      }

      function midpoint(p1, p2) {
        return {
          x: (p1.x + p2.x) / 2,
          y: (p1.y + p2.y) / 2,
        };
      }

      function rotatePoint(x, y, cx, cy, angle) {
        const dx = x - cx;
        const dy = y - cy;
        return {
          x: cx + dx * Math.cos(angle) - dy * Math.sin(angle),
          y: cy + dx * Math.sin(angle) + dy * Math.cos(angle),
        };
      }

      function drawSierpinskiTriangle(ctx, points, depth) {
        if (depth === 0) {
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          ctx.lineTo(points[1].x, points[1].y);
          ctx.lineTo(points[2].x, points[2].y);
          ctx.closePath();
          ctx.fill();
          return;
        }
        const [a, b, c] = points;
        const ab = midpoint(a, b);
        const bc = midpoint(b, c);
        const ac = midpoint(a, c);
        drawSierpinskiTriangle(ctx, [a, ab, ac], depth - 1);
        drawSierpinskiTriangle(ctx, [ab, b, bc], depth - 1);
        drawSierpinskiTriangle(ctx, [ac, bc, c], depth - 1);
      }

      function drawSierpinski(ctx, opts) {
        const { width, height, depth, color, scale, bias } = opts;
        const motion = opts.motion || {};
        const offsetX = motion.x || 0;
        const offsetY = motion.y || 0;
        const rotation = motion.rotation || 0;
        const radius = Math.min(width, height) * (0.25 + scale * 0.22);
        const points = [
          { x: 0, y: -radius },
          { x: -radius, y: radius },
          { x: radius, y: radius },
        ].map((point) => rotatePoint(point.x, point.y, 0, 0, bias * 0.65));
        ctx.save();
        ctx.translate(width / 2 + offsetX, height * 0.55 + offsetY);
        ctx.rotate(rotation);
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.5;
        drawSierpinskiTriangle(ctx, points, Math.min(depth, 8));
        ctx.restore();
      }

      function drawSpiral(ctx, opts) {
        const { width, height, depth, scale, color, sliderAngle, branchFactor } = opts;
        const motion = opts.motion || {};
        const offsetX = motion.x || 0;
        const offsetY = motion.y || 0;
        const rotation = motion.rotation || 0;
        ctx.save();
        ctx.translate(width / 2 + offsetX, height / 2 + offsetY);
        ctx.rotate(rotation);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.2;
        const previousShadowBlur = ctx.shadowBlur;
        const previousShadowColor = ctx.shadowColor;
        ctx.shadowBlur = 16;
        ctx.shadowColor = color;
        let x = 0;
        let y = 0;
        const margin = Math.min(width, height) * 0.08;
        const maxLength = Math.max(
          22,
          Math.min(width, height) * (0.38 + Math.min(scale, 0.75) * 0.25) - margin
        );
        let length = maxLength;
        let currentAngle = sliderAngle;
        const shrink = 0.915 - Math.min(scale, 0.7) * 0.12;
        const steps = depth * 10 + branchFactor * 4;
        for (let step = 0; step < steps && length > 3; step += 1) {
          const nextX = x + Math.cos(currentAngle) * length;
          const nextY = y + Math.sin(currentAngle) * length;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(nextX, nextY);
          ctx.stroke();
          x = nextX;
          y = nextY;
          length *= shrink;
          currentAngle +=
            (Math.PI / (22 + step)) + (branchFactor * 0.02) + Math.sin(step * 0.2) * 0.04;
          if (Math.abs(x) > width / 2 - margin || Math.abs(y) > height / 2 - margin) {
            length *= 0.85;
            currentAngle += 0.08;
          }
        }
        ctx.shadowBlur = previousShadowBlur;
        ctx.shadowColor = previousShadowColor;
        ctx.restore();
      }

      const fractalDrawers = {
        tree: drawBinaryTree,
        triangle: drawSierpinski,
        spiral: drawSpiral,
      };

      function renderFractal() {
        const width = fractalCanvas.width;
        const height = fractalCanvas.height;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = 'rgba(1, 2, 5, 0.65)';
        ctx.fillRect(0, 0, width, height);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        advanceMotion();
        const scaleFactor = Math.max(0.2, parseFloat(scaleRange.value) / 100);
        const branchFactor = parseInt(branchFactorRange.value, 10);
        const branchSpread = Math.PI * (0.35 + branchFactor * 0.08);
        const sliderAngle = (parseInt(angleRange.value, 10) * Math.PI) / 180;
        const depthValueInput = parseInt(depthRange.value, 10);
        const fractalType = fractalTypeSelect.value;
        const options = {
          width,
          height,
          depth: fractalType === 'triangle' ? Math.min(depthValueInput, 7) : depthValueInput,
          scale: scaleFactor,
          color: branchColor.value,
          sliderAngle,
          branchFactor,
          branchSpread,
          bias: Math.cos(branchFactor * 0.35),
          motion: {
            x: fractalMotion.currentX,
            y: fractalMotion.currentY,
            rotation: fractalMotion.currentRotation,
          },
        };
        fractalDrawers[fractalType](ctx, options);
      }

      function startFractalLoop() {
        if (fractalAnimationId) {
          cancelAnimationFrame(fractalAnimationId);
        }
        const loop = () => {
          renderFractal();
          fractalAnimationId = requestAnimationFrame(loop);
        };
        fractalAnimationId = requestAnimationFrame(loop);
      }

      function initializeFractal() {
        updateControlLabels();
        updateMotionTargets();
        resizeCanvas();
        renderFractal();
      }

      const controlElements = [
        depthRange,
        angleRange,
        scaleRange,
        branchFactorRange,
        fractalTypeSelect,
      ];

      controlElements.forEach((element) => {
        element.addEventListener('input', () => {
          updateControlLabels();
          updateMotionTargets();
          renderFractal();
        });
      });

      branchColor.addEventListener('input', renderFractal);

      window.addEventListener('resize', () => {
        resizeCanvas();
        renderFractal();
      });

      piDisplay.textContent = formatConstantDigits(piDigits);
      eDisplay.textContent = formatConstantDigits(eDigits);
      initializeFractal();
      startFractalLoop();
      startApproximationLoop();

      // Hanoi towers
      const diskCountInput = document.getElementById('diskCount');
      const diskCountValue = document.getElementById('diskCountValue');
      const fromSelect = document.getElementById('fromTower');
      const toSelect = document.getElementById('toTower');
      const moveButton = document.getElementById('moveDisk');
      const autoSolveButton = document.getElementById('autoSolve');
      const resetButton = document.getElementById('resetHanoi');
      const messageEl = document.getElementById('hanoiMessage');
      const towerEls = document.querySelectorAll('.tower');
      let towers = [[], [], []];
      let diskCount = parseInt(diskCountInput.value, 10);
      let autoTimer;
      let dragOrigin = null;

      function createDisks(count) {
        const stack = [];
        for (let i = count; i >= 1; i -= 1) {
          stack.push(i);
        }
        return stack;
      }

      function renderHanoi() {
        towerEls.forEach((towerEl) => {
          const idx = Number(towerEl.dataset.index);
        towerEl.innerHTML = '';
          const stack = towers[idx] || [];
          const ordered = [...stack].sort((a, b) => b - a);
          ordered.forEach((diskSize) => {
            const disk = document.createElement('div');
            disk.className = 'disk';
            const widthRatio = (diskSize / diskCount) * 0.7 + 0.3;
            disk.style.width = `${widthRatio * 100}%`;
            disk.style.background = `linear-gradient(90deg, rgba(0,255,255,0.4), rgba(255,0,255,0.4))`;
            disk.style.order = diskSize;
            towerEl.appendChild(disk);
          });
        });
      }

      function setMessage(text) {
        messageEl.textContent = text;
      }

      function resetHanoi() {
        clearDragHighlight();
        if (autoTimer) {
          clearInterval(autoTimer);
          autoTimer = null;
        }
        diskCount = parseInt(diskCountInput.value, 10);
        diskCountValue.textContent = diskCount;
        towers = [createDisks(diskCount), [], []];
        renderHanoi();
        setMessage(`ディスク数 ${diskCount} で初期化されました。`);
      }

      function moveDisk(from, to, silent = false) {
        if (from === to) {
          if (!silent) setMessage('異なる塔を選んでください。');
          return false;
        }
        const source = towers[from];
        const target = towers[to];
        if (source.length === 0) {
          if (!silent) setMessage('開始塔にディスクがありません。');
          return false;
        }
        const disk = source[source.length - 1];
        const targetTop = target[target.length - 1];
        if (targetTop && disk > targetTop) {
          if (!silent) setMessage('大きなディスクを小さなディスクの上に置けません。');
          return false;
        }
        target.push(source.pop());
        renderHanoi();
        if (!silent) setMessage(`塔 ${String.fromCharCode(65 + from)} -> ${String.fromCharCode(65 + to)} に移動しました。`);
        return true;
      }

      function solveHanoi(n, from, to, aux, moves) {
        if (n === 0) return;
        solveHanoi(n - 1, from, aux, to, moves);
        moves.push([from, to]);
        solveHanoi(n - 1, aux, to, from, moves);
      }

      diskCountInput.addEventListener('input', () => {
        diskCountValue.textContent = diskCountInput.value;
      });

      function clearDragHighlight() {
        dragOrigin = null;
        towerEls.forEach((el) => {
          el.classList.remove('tower-drag-source', 'tower-drag-target');
        });
      }

      towerEls.forEach((towerEl) => {
        towerEl.addEventListener('pointerdown', (event) => {
          event.preventDefault();
          const idx = Number(towerEl.dataset.index);
          if (towers[idx].length === 0) {
            setMessage('この塔にディスクがありません。');
            return;
          }
          dragOrigin = idx;
          towerEl.classList.add('tower-drag-source');
          setMessage(`塔 ${String.fromCharCode(65 + idx)} からドラッグを開始しました。`);
        });
        towerEl.addEventListener('pointerenter', () => {
          if (dragOrigin === null) return;
          const idx = Number(towerEl.dataset.index);
          if (idx !== dragOrigin) {
            towerEl.classList.add('tower-drag-target');
          }
        });
        towerEl.addEventListener('pointerleave', () => {
          towerEl.classList.remove('tower-drag-target');
        });
        towerEl.addEventListener('pointerup', () => {
          if (dragOrigin === null) return;
          const target = Number(towerEl.dataset.index);
          if (target !== dragOrigin) {
            moveDisk(dragOrigin, target);
          } else {
            setMessage('同じ塔には戻せません。');
          }
          clearDragHighlight();
        });
      });

      document.addEventListener('pointerup', (event) => {
        if (dragOrigin === null) return;
        if (!event.target.closest('.tower')) {
          clearDragHighlight();
          setMessage('ドラッグをキャンセルしました。');
        }
      });

      moveButton.addEventListener('click', () => {
        const from = Number(fromSelect.value);
        const to = Number(toSelect.value);
        moveDisk(from, to);
      });

      autoSolveButton.addEventListener('click', () => {
        if (autoTimer) {
          clearInterval(autoTimer);
        }
        const moves = [];
        solveHanoi(diskCount, 0, 2, 1, moves);
        let index = 0;
        autoSolveButton.disabled = true;
        setMessage('自動解答を開始します。');
        autoTimer = setInterval(() => {
          if (index >= moves.length) {
            clearInterval(autoTimer);
            autoTimer = null;
            autoSolveButton.disabled = false;
            setMessage('自動解答が完了しました。');
            return;
          }
          const [from, to] = moves[index];
          moveDisk(from, to, true);
          index += 1;
        }, 420);
      });

      resetButton.addEventListener('click', () => {
        resetHanoi();
      });

      // Circle avoidance game
      const circleBoard = document.getElementById('circleBoard');
      const circleMessage = document.getElementById('circleMessage');
      const circleAiInfo = document.getElementById('circleAiInfo');
      const circleHumanScoreEl = document.getElementById('circleHumanScore');
      const circleAiScoreEl = document.getElementById('circleAiScore');
      const circleDrawsEl = document.getElementById('circleDraws');
      const circleFirstPlayer = document.getElementById('circleFirstPlayer');
      const circleResetButton = document.getElementById('circleReset');
      const circleOverlay = document.getElementById('circleOverlay');
      const circleBoardSize = 9;
      const circleCells = [];
      let circleBoardState = [];
      let circleCurrentPlayer = 1;
      let circleGameOver = false;
      let circleLastMove = null;
      let circleAiTimer = null;
      let circleHumanWins = 0;
      let circleAiWins = 0;
      let circleDrawGames = 0;
      let circleAiMoves = [];
      const circleExperience = loadCircleExperience();

      function loadCircleExperience() {
        try {
          const stored = localStorage.getItem('circleAvoidAI');
          return stored ? JSON.parse(stored) : {};
        } catch (error) {
          return {};
        }
      }

      function saveCircleExperience() {
        try {
          localStorage.setItem('circleAvoidAI', JSON.stringify(circleExperience));
        } catch (error) {
          // ignore storage failures
        }
      }

      function updateAiStatsDisplay() {
        const entries = Object.values(circleExperience);
        const total = entries.reduce((sum, entry) => sum + entry.total, 0);
        const wins = entries.reduce((sum, entry) => sum + entry.wins, 0);
        const rate = total ? Math.round((wins / total) * 100) : 0;
        circleAiInfo.textContent = `学習エントリ ${entries.length} 件 / 勝率 ${rate}% / 訓練 ${total} 回`;
      }

      function buildCircleCells() {
        circleCells.length = 0;
        circleBoard.innerHTML = '';
        for (let row = 0; row < circleBoardSize; row += 1) {
          const rowCells = [];
          for (let col = 0; col < circleBoardSize; col += 1) {
            const cell = document.createElement('button');
            cell.type = 'button';
            cell.className = 'circle-cell';
            cell.dataset.row = row;
            cell.dataset.col = col;
            cell.dataset.player = '0';
            const stone = document.createElement('span');
            stone.className = 'stone';
            cell.appendChild(stone);
            cell.addEventListener('click', () => handleCircleClick(row, col));
            circleBoard.appendChild(cell);
            rowCells.push(cell);
          }
          circleCells.push(rowCells);
        }
      }

      function resetCircleGame() {
        if (circleAiTimer) {
          clearTimeout(circleAiTimer);
          circleAiTimer = null;
        }
        circleAiMoves = [];
        circleGameOver = false;
        circleBoardState = Array.from({ length: circleBoardSize }, () =>
          Array.from({ length: circleBoardSize }, () => 0)
        );
        circleLastMove = null;
        circleCurrentPlayer = circleFirstPlayer.value === 'ai' ? 2 : 1;
        renderCircleBoard();
        circleMessage.textContent =
          circleCurrentPlayer === 2
            ? 'AIが先手で形を探ります…'
            : 'あなたから打ち始めます。';
        if (circleCurrentPlayer === 2) {
          scheduleAiTurn();
        }
      }

      function updateScoreboard() {
        circleHumanScoreEl.textContent = `${circleHumanWins} 勝`;
        circleAiScoreEl.textContent = `${circleAiWins} 勝`;
        circleDrawsEl.textContent = `${circleDrawGames} 回`;
      }

      function renderCircleBoard() {
        circleBoardState.forEach((row, rowIndex) => {
          row.forEach((value, colIndex) => {
            const cell = circleCells[rowIndex][colIndex];
            cell.dataset.player = String(value);
            const isLast =
              circleLastMove &&
              circleLastMove.row === rowIndex &&
              circleLastMove.col === colIndex;
            cell.classList.toggle('circle-cell--last', Boolean(isLast));
          });
        });
        updateCircleOverlay();
      }

      function updateCircleOverlay() {
        if (!circleOverlay) return;
        const points = [];
        for (let r = 0; r < circleBoardSize; r += 1) {
          for (let c = 0; c < circleBoardSize; c += 1) {
            if (circleBoardState[r][c]) {
              points.push({ x: c, y: r });
            }
          }
        }
        if (points.length < 3) {
          circleOverlay.innerHTML = '';
          return;
        }
        const seen = new Set();
        const circles = [];
        outer: for (let i = 0; i < points.length - 2; i += 1) {
          for (let j = i + 1; j < points.length - 1; j += 1) {
            for (let k = j + 1; k < points.length; k += 1) {
              const circle = computeCircle(points[i], points[j], points[k]);
              if (!circle) continue;
              if (circle.radius > circleBoardSize * 1.5) continue;
              const key = `${circle.center.x.toFixed(2)}|${circle.center.y.toFixed(2)}|${circle.radius.toFixed(2)}`;
              if (seen.has(key)) continue;
              seen.add(key);
              circles.push(circle);
              if (circles.length >= 6) {
                break outer;
              }
            }
          }
        }
        circleOverlay.innerHTML = circles
          .map(
            (circle) =>
              `<circle cx="${(circle.center.x + 0.5).toFixed(3)}" cy="${(
                circle.center.y + 0.5
              ).toFixed(3)}" r="${circle.radius.toFixed(3)}" stroke="rgba(255,255,255,0.6)" stroke-width="0.04" fill="none" />`
          )
          .join('');
      }

      function isBoardFull() {
        return circleBoardState.every((row) => row.every((cell) => cell !== 0));
      }

      function getBoardKey() {
        return circleBoardState.map((row) => row.join('')).join('|');
      }

      function chooseAiMove(stateKey) {
        const empties = [];
        for (let row = 0; row < circleBoardSize; row += 1) {
          for (let col = 0; col < circleBoardSize; col += 1) {
            if (circleBoardState[row][col] === 0) {
              const move = { row, col };
              const loses = checkCircleLoss(row, col);
              empties.push({ ...move, loses });
            }
          }
        }
        if (empties.length === 0) return null;
        const safeMoves = empties.filter((option) => !option.loses);
        const candidates = safeMoves.length ? safeMoves : empties;
        if (Math.random() < 0.2) {
          const pick = candidates[Math.floor(Math.random() * candidates.length)];
          return { row: pick.row, col: pick.col, moveKey: `${stateKey}|${pick.row},${pick.col}` };
        }
        let best = null;
        let bestScore = -Infinity;
        const centerCoord = (circleBoardSize - 1) / 2;
        candidates.forEach((move) => {
          const moveKey = `${stateKey}|${move.row},${move.col}`;
          const record = circleExperience[moveKey];
          const baseRate = record && record.total ? record.wins / record.total : 0.33;
          const novelty = 1 - Math.min(1, (record?.total ?? 0) / 10);
          const distanceScore =
            -Math.hypot(move.row - centerCoord, move.col - centerCoord) * 0.035;
          const score = baseRate + novelty * 0.18 + distanceScore;
          if (score > bestScore) {
            bestScore = score;
            best = { row: move.row, col: move.col, moveKey };
          }
        });
        if (!best) {
          const fallback = candidates[Math.floor(Math.random() * candidates.length)];
          return { row: fallback.row, col: fallback.col, moveKey: `${stateKey}|${fallback.row},${fallback.col}` };
        }
        return best;
      }

      function scheduleAiTurn() {
        if (circleGameOver) return;
        if (circleAiTimer) {
          clearTimeout(circleAiTimer);
          circleAiTimer = null;
        }
        circleMessage.textContent = 'AIが読みを進めています…';
        circleAiTimer = setTimeout(() => {
          circleAiTimer = null;
          if (circleGameOver) return;
          const stateKey = getBoardKey();
          const move = chooseAiMove(stateKey);
          if (!move) {
            finalizeCircleGame('draw', 'これ以上打てる場所がありません。');
            return;
          }
          circleAiMoves.push(move.moveKey);
          makeCircleMove(move.row, move.col, 2);
        }, 560);
      }

      function finalizeCircleGame(outcome, message) {
        circleGameOver = true;
        if (circleAiTimer) {
          clearTimeout(circleAiTimer);
          circleAiTimer = null;
        }
        if (outcome === 'human') {
          circleHumanWins += 1;
        } else if (outcome === 'ai') {
          circleAiWins += 1;
        } else {
          circleDrawGames += 1;
        }
        updateScoreboard();
        circleMessage.textContent = message;
        learnFromExperience(outcome === 'ai');
      }

      function learnFromExperience(aiWon) {
        if (!circleAiMoves.length) {
          updateAiStatsDisplay();
          return;
        }
        circleAiMoves.forEach((moveKey) => {
          const record = circleExperience[moveKey] || { wins: 0, total: 0 };
          record.total += 1;
          if (aiWon) {
            record.wins += 1;
          }
          circleExperience[moveKey] = record;
        });
        circleAiMoves = [];
        saveCircleExperience();
        updateAiStatsDisplay();
      }

      function makeCircleMove(row, col, player) {
        const loses = checkCircleLoss(row, col);
        circleBoardState[row][col] = player;
        circleLastMove = { row, col };
        renderCircleBoard();
        if (loses) {
          const winner = player === 1 ? 'ai' : 'human';
          const reason =
            player === 1
              ? 'あなたは円の円周上に4点を作ってしまいました。'
              : 'AIが円上に4点を置いてしまいました。';
          finalizeCircleGame(winner, reason);
          return;
        }
        if (isBoardFull()) {
          finalizeCircleGame('draw', '盤面がすべて埋まりました。');
          return;
        }
        circleCurrentPlayer = player === 1 ? 2 : 1;
        circleMessage.textContent =
          circleCurrentPlayer === 2
            ? 'AIの番です。'
            : 'あなたの番です。円上の4点を避けてください。';
        if (circleCurrentPlayer === 2) {
          scheduleAiTurn();
        }
      }

      function handleCircleClick(row, col) {
        if (circleGameOver || circleCurrentPlayer !== 1) {
          return;
        }
        if (circleBoardState[row][col] !== 0) {
          circleMessage.textContent = 'そこにはすでに石があります。';
          return;
        }
        makeCircleMove(row, col, 1);
      }

      function checkCircleLoss(row, col) {
        const existingStones = [];
        for (let r = 0; r < circleBoardSize; r += 1) {
          for (let c = 0; c < circleBoardSize; c += 1) {
            if (circleBoardState[r][c]) {
              existingStones.push({ x: c, y: r });
            }
          }
        }
        if (existingStones.length < 3) return false;
        const newPoint = { x: col, y: row };
        const tolerance = 0.04;
        for (let i = 0; i < existingStones.length - 2; i += 1) {
          for (let j = i + 1; j < existingStones.length - 1; j += 1) {
            for (let k = j + 1; k < existingStones.length; k += 1) {
              const circle = computeCircle(existingStones[i], existingStones[j], existingStones[k]);
              if (!circle) continue;
              const diff = Math.abs(distance(circle.center, newPoint) - circle.radius);
              if (diff < tolerance) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function computeCircle(p1, p2, p3) {
        const d =
          2 *
          (p1.x * (p2.y - p3.y) +
            p2.x * (p3.y - p1.y) +
            p3.x * (p1.y - p2.y));
        if (Math.abs(d) < 1e-6) return null;
        const aSq = p1.x * p1.x + p1.y * p1.y;
        const bSq = p2.x * p2.x + p2.y * p2.y;
        const cSq = p3.x * p3.x + p3.y * p3.y;
        const ux =
          (aSq * (p2.y - p3.y) + bSq * (p3.y - p1.y) + cSq * (p1.y - p2.y)) / d;
        const uy =
          (aSq * (p3.x - p2.x) + bSq * (p1.x - p3.x) + cSq * (p2.x - p1.x)) / d;
        const center = { x: ux, y: uy };
        const radius = distance(center, p1);
        return Number.isFinite(radius) ? { center, radius } : null;
      }

      function distance(p1, p2) {
        return Math.hypot(p1.x - p2.x, p1.y - p2.y);
      }

      circleFirstPlayer.addEventListener('change', resetCircleGame);
      circleResetButton.addEventListener('click', resetCircleGame);
      buildCircleCells();
      updateScoreboard();
      updateAiStatsDisplay();
      resetCircleGame();

      // initial setup
      initializeFractal();
      resetHanoi();
    </script>
  </body>
</html>
